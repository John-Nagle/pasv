  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.49 (2010-07-07) <http://clisp.cons.org/>

Copyright (c) Bruno Haible, Michael Stoll 1992, 1993
Copyright (c) Bruno Haible, Marcus Daniels 1994-1997
Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998
Copyright (c) Bruno Haible, Sam Steingold 1999-2000
Copyright (c) Sam Steingold, Bruno Haible 2001-2010

Type :h and hit Enter for context help.

;; Loading file /home/john/.clisprc ...
;; Loaded file /home/john/.clisprc
[1]> 
;; Loading file nqthm.lisp ...
;; Loaded file nqthm.lisp
T
[2]> 
#<PACKAGE COMMON-LISP-USER>
[3]> 
;; Loading file /home/john/projects/nqthm/nqthm-1992/sloop.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/sloop.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/basis.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/basis.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/genfact.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/genfact.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/events.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/events.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/code-1-a.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/code-1-a.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/code-b-d.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/code-b-d.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/code-e-m.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/code-e-m.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/code-n-r.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/code-n-r.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/code-s-z.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/code-s-z.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/io.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/io.fas
;; Loading file /home/john/projects/nqthm/nqthm-1992/ppr.fas ...
;; Loaded file /home/john/projects/nqthm/nqthm-1992/ppr.fas
T
[4]> 

NQTHM Version 1992.  See the license agreement at the beginning
of the file "basis.lisp" for the terms and conditions on the
use and modification of this software.  To avoid this warning,
(SETQ *THM-SUPPRESS-DISCLAIMER-FLG* T).

Robert S. Boyer and J Strother Moore


[ 0.0 0.1 0.0 ]
GROUND-ZERO
[5]> 
;; Loading file ../../verifier/pasv/src/work/temporaryrulebase.lisp ...
(PROVE-LEMMA PLUS-0 (REWRITE) (EQUAL (PLUS X 0) (FIX X)))
This simplifies, unfolding FIX, to two new formulas:

Case 2. (IMPLIES (NOT (NUMBERP X))
                 (EQUAL (PLUS X 0) 0)),

  which again simplifies, unfolding NUMBERP, PLUS, and EQUAL, to:

        T.

Case 1. (IMPLIES (NUMBERP X)
                 (EQUAL (PLUS X 0) X)),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-1 (REWRITE) (IMPLIES (NUMBERP X) (EQUAL (PLUS 1 X) (ADD1 X))))
This simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-ADD1 (REWRITE) (EQUAL (PLUS X (ADD1 Y)) (IF (NUMBERP Y) (ADD1 (PLUS X Y)) (ADD1 X))))
This simplifies, obviously, to two new formulas:

Case 2. (IMPLIES (NOT (NUMBERP Y))
                 (EQUAL (PLUS X (ADD1 Y)) (ADD1 X))),

  which again simplifies, rewriting with the lemma SUB1-TYPE-RESTRICTION, to
  the conjecture:

        (IMPLIES (NOT (NUMBERP Y))
                 (EQUAL (PLUS X 1) (ADD1 X))).

  But this again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (NUMBERP Y)
                 (EQUAL (PLUS X (ADD1 Y))
                        (ADD1 (PLUS X Y)))),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-CANCELLATION (REWRITE) (EQUAL (EQUAL (PLUS A B) (PLUS A C)) (EQUAL (FIX B) (FIX C))))
This conjecture simplifies, expanding the definition of FIX, to the following
seven new formulas:

Case 7. (IMPLIES (AND (NUMBERP C)
                      (NUMBERP B)
                      (NOT (EQUAL B C)))
                 (NOT (EQUAL (PLUS A B) (PLUS A C)))).

  This again simplifies, using linear arithmetic, to:

        T.

Case 6. (IMPLIES (AND (NUMBERP C)
                      (NOT (NUMBERP B))
                      (NOT (EQUAL 0 C)))
                 (NOT (EQUAL (PLUS A B) (PLUS A C)))),

  which we will name *1.

Case 5. (IMPLIES (AND (NOT (NUMBERP C))
                      (NUMBERP B)
                      (NOT (EQUAL B 0)))
                 (NOT (EQUAL (PLUS A B) (PLUS A C)))),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(EQUAL (EQUAL (PLUS A B) (PLUS A C))
       (EQUAL (FIX B) (FIX C))).

We gave this the name *1 above.  Perhaps we can prove it by induction.  Two
inductions are suggested by terms in the conjecture.  However, they merge into
one likely candidate induction.  We will induct according to the following
scheme:
      (AND (IMPLIES (ZEROP A) (p A B C))
           (IMPLIES (AND (NOT (ZEROP A)) (p (SUB1 A) B C))
                    (p A B C))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definition
of ZEROP inform us that the measure (COUNT A) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme produces the following two new formulas:

Case 2. (IMPLIES (ZEROP A)
                 (EQUAL (EQUAL (PLUS A B) (PLUS A C))
                        (EQUAL (FIX B) (FIX C)))).

  This simplifies, expanding the functions ZEROP, EQUAL, PLUS, and FIX, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP A))
                      (EQUAL (EQUAL (PLUS (SUB1 A) B)
                                    (PLUS (SUB1 A) C))
                             (EQUAL (FIX B) (FIX C))))
                 (EQUAL (EQUAL (PLUS A B) (PLUS A C))
                        (EQUAL (FIX B) (FIX C)))).

  This simplifies, rewriting with ADD1-EQUAL and PLUS-0, and unfolding the
  definitions of ZEROP, FIX, PLUS, and EQUAL, to two new goals:

  Case 1.2.
          (IMPLIES (AND (NOT (EQUAL A 0))
                        (NUMBERP A)
                        (NOT (NUMBERP C))
                        (EQUAL B 0)
                        (EQUAL (EQUAL (PLUS (SUB1 A) B)
                                      (PLUS (SUB1 A) C))
                               T))
                   (EQUAL A (ADD1 (PLUS (SUB1 A) C)))),

    which again simplifies, rewriting with the lemmas PLUS-0 and ADD1-SUB1, to:

          T.

  Case 1.1.
          (IMPLIES (AND (NOT (EQUAL A 0))
                        (NUMBERP A)
                        (NOT (NUMBERP B))
                        (EQUAL 0 C)
                        (EQUAL (EQUAL (PLUS (SUB1 A) B)
                                      (PLUS (SUB1 A) C))
                               T))
                   (EQUAL (ADD1 (PLUS (SUB1 A) B)) A)),

    which again simplifies, rewriting with PLUS-0 and ADD1-SUB1, to:

          T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-DIFFERENCE3 (REWRITE) (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z)) (DIFFERENCE Y Z)))
This simplifies, using linear arithmetic, to the following two new conjectures:

Case 2. (IMPLIES (LESSP (PLUS X Y) (PLUS X Z))
                 (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                        (DIFFERENCE Y Z))).

  Give the above formula the name *1.

Case 1. (IMPLIES (LESSP Y Z)
                 (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                        (DIFFERENCE Y Z))),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
       (DIFFERENCE Y Z)).

We gave this the name *1 above.  Perhaps we can prove it by induction.  There
are four plausible inductions.  They merge into two likely candidate
inductions.  However, only one is unflawed.  We will induct according to the
following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definition
of ZEROP establish that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme produces the following two new conjectures:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                        (DIFFERENCE Y Z))).

  This simplifies, using linear arithmetic, to the following two new goals:

  Case 2.2.
          (IMPLIES (AND (LESSP (PLUS X Y) (PLUS X Z))
                        (ZEROP X))
                   (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                          (DIFFERENCE Y Z))).

    But this again simplifies, unfolding the functions PLUS, ZEROP, EQUAL, and
    DIFFERENCE, to:

          T.

  Case 2.1.
          (IMPLIES (AND (LESSP Y Z) (ZEROP X))
                   (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                          (DIFFERENCE Y Z))),

    which again simplifies, opening up ZEROP, EQUAL, and PLUS, to six new
    goals:

    Case 2.1.6.
            (IMPLIES (AND (LESSP Y Z)
                          (EQUAL X 0)
                          (NOT (NUMBERP Z))
                          (NOT (NUMBERP Y)))
                     (EQUAL (DIFFERENCE 0 0)
                            (DIFFERENCE Y Z))),

      which again simplifies, opening up LESSP, to:

            T.

    Case 2.1.5.
            (IMPLIES (AND (LESSP Y Z)
                          (EQUAL X 0)
                          (NOT (NUMBERP Z))
                          (NUMBERP Y))
                     (EQUAL (DIFFERENCE Y 0)
                            (DIFFERENCE Y Z))),

      which again simplifies, opening up LESSP, to:

            T.

    Case 2.1.4.
            (IMPLIES (AND (LESSP Y Z)
                          (EQUAL X 0)
                          (NUMBERP Z)
                          (NOT (NUMBERP Y)))
                     (EQUAL (DIFFERENCE 0 Z)
                            (DIFFERENCE Y Z))),

      which again simplifies, expanding LESSP, EQUAL, and DIFFERENCE, to:

            T.

    Case 2.1.3.
            (IMPLIES (AND (LESSP Y Z)
                          (NOT (NUMBERP X))
                          (NOT (NUMBERP Z))
                          (NOT (NUMBERP Y)))
                     (EQUAL (DIFFERENCE 0 0)
                            (DIFFERENCE Y Z))),

      which again simplifies, unfolding the definition of LESSP, to:

            T.

    Case 2.1.2.
            (IMPLIES (AND (LESSP Y Z)
                          (NOT (NUMBERP X))
                          (NOT (NUMBERP Z))
                          (NUMBERP Y))
                     (EQUAL (DIFFERENCE Y 0)
                            (DIFFERENCE Y Z))),

      which again simplifies, expanding LESSP, to:

            T.

    Case 2.1.1.
            (IMPLIES (AND (LESSP Y Z)
                          (NOT (NUMBERP X))
                          (NUMBERP Z)
                          (NOT (NUMBERP Y)))
                     (EQUAL (DIFFERENCE 0 Z)
                            (DIFFERENCE Y Z))),

      which again simplifies, unfolding the definitions of LESSP, EQUAL, and
      DIFFERENCE, to:

            T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (DIFFERENCE (PLUS (SUB1 X) Y)
                                         (PLUS (SUB1 X) Z))
                             (DIFFERENCE Y Z)))
                 (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                        (DIFFERENCE Y Z))),

  which simplifies, using linear arithmetic, to two new conjectures:

  Case 1.2.
          (IMPLIES (AND (LESSP (PLUS X Y) (PLUS X Z))
                        (NOT (ZEROP X))
                        (EQUAL (DIFFERENCE (PLUS (SUB1 X) Y)
                                           (PLUS (SUB1 X) Z))
                               (DIFFERENCE Y Z)))
                   (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                          (DIFFERENCE Y Z))),

    which again simplifies, applying SUB1-ADD1, and unfolding PLUS, ZEROP, and
    DIFFERENCE, to:

          T.

  Case 1.1.
          (IMPLIES (AND (LESSP Y Z)
                        (NOT (ZEROP X))
                        (EQUAL (DIFFERENCE (PLUS (SUB1 X) Y)
                                           (PLUS (SUB1 X) Z))
                               (DIFFERENCE Y Z)))
                   (EQUAL (DIFFERENCE (PLUS X Y) (PLUS X Z))
                          (DIFFERENCE Y Z))).

    But this again simplifies, applying the lemma SUB1-ADD1, and expanding the
    definitions of ZEROP, PLUS, and DIFFERENCE, to:

          T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-EQUAL-0 (REWRITE) (EQUAL (EQUAL (PLUS A B) 0) (AND (ZEROP A) (ZEROP B))))
This simplifies, opening up the functions ZEROP and AND, to six new
conjectures:

Case 6. (IMPLIES (AND (NOT (EQUAL (PLUS A B) 0))
                      (NOT (NUMBERP A)))
                 (NOT (EQUAL B 0))),

  which again simplifies, applying PLUS-0, and unfolding the function EQUAL,
  to:

        T.

Case 5. (IMPLIES (AND (NOT (EQUAL (PLUS A B) 0))
                      (NOT (NUMBERP A)))
                 (NUMBERP B)).

  However this again simplifies, expanding PLUS and EQUAL, to:

        T.

Case 4. (IMPLIES (AND (NOT (EQUAL (PLUS A B) 0))
                      (EQUAL A 0))
                 (NOT (EQUAL B 0))),

  which again simplifies, using linear arithmetic, to:

        T.

Case 3. (IMPLIES (AND (NOT (EQUAL (PLUS A B) 0))
                      (EQUAL A 0))
                 (NUMBERP B)),

  which again simplifies, opening up the definitions of EQUAL and PLUS, to:

        T.

Case 2. (IMPLIES (AND (EQUAL (PLUS A B) 0)
                      (NOT (EQUAL A 0)))
                 (NOT (NUMBERP A))),

  which again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (EQUAL (PLUS A B) 0)
                      (NOT (EQUAL B 0)))
                 (NOT (NUMBERP B))),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-NON-NUMBERP (REWRITE) (IMPLIES (NOT (NUMBERP Y)) (EQUAL (PLUS X Y) (FIX X))))
This simplifies, unfolding the definition of FIX, to the following two new
goals:

Case 2. (IMPLIES (AND (NOT (NUMBERP Y))
                      (NOT (NUMBERP X)))
                 (EQUAL (PLUS X Y) 0)).

  This again simplifies, opening up the definitions of PLUS and EQUAL, to:

        T.

Case 1. (IMPLIES (AND (NOT (NUMBERP Y)) (NUMBERP X))
                 (EQUAL (PLUS X Y) X)),

  which we will name *1.


     We will appeal to induction.  There is only one plausible induction.  We
will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y))
                    (p X Y))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definition
of ZEROP establish that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme generates the following two new formulas:

Case 2. (IMPLIES (AND (ZEROP X)
                      (NOT (NUMBERP Y))
                      (NUMBERP X))
                 (EQUAL (PLUS X Y) X)).

  This simplifies, expanding the functions ZEROP, NUMBERP, EQUAL, and PLUS, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (PLUS (SUB1 X) Y) (SUB1 X))
                      (NOT (NUMBERP Y))
                      (NUMBERP X))
                 (EQUAL (PLUS X Y) X)).

  This simplifies, using linear arithmetic, to the new conjecture:

        (IMPLIES (AND (EQUAL X 0)
                      (NOT (ZEROP X))
                      (EQUAL (PLUS (SUB1 X) Y) (SUB1 X))
                      (NOT (NUMBERP Y))
                      (NUMBERP X))
                 (EQUAL (PLUS X Y) X)),

  which again simplifies, expanding the function ZEROP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA PLUS-RIGHT-ID2 (REWRITE) (IMPLIES (NOT (NUMBERP Y)) (EQUAL (PLUS X Y) (FIX X))))
WARNING:  the previously added lemma, PLUS-NON-NUMBERP, could be applied
whenever the newly proposed PLUS-RIGHT-ID2 could!


This simplifies, rewriting with PLUS-NON-NUMBERP, and expanding FIX, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA EQUAL-LESSP (REWRITE) (EQUAL (EQUAL (LESSP X Y) Z) (IF (LESSP X Y) (EQUAL T Z) (EQUAL F Z))))
This simplifies, clearly, to the following four new formulas:

Case 4. (IMPLIES (AND (EQUAL (LESSP X Y) Z)
                      (NOT (LESSP X Y)))
                 (NOT Z)).

  This again simplifies, trivially, to:

        T.

Case 3. (IMPLIES (AND (NOT (EQUAL (LESSP X Y) Z))
                      (NOT (LESSP X Y)))
                 Z).

  This again simplifies, clearly, to:

        T.

Case 2. (IMPLIES (AND (NOT (EQUAL (LESSP X Y) Z))
                      (LESSP X Y))
                 (NOT (EQUAL T Z))).

  This again simplifies, obviously, to:

        T.

Case 1. (IMPLIES (AND (EQUAL (LESSP X Y) Z)
                      (LESSP X Y))
                 (EQUAL (EQUAL T Z) T)).

  This again simplifies, obviously, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA ASSOCIATIVITY-OF-PLUS (REWRITE) (EQUAL (PLUS (PLUS X Y) Z) (PLUS X (PLUS Y Z))))
This simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA COMMUTATIVITY-OF-PLUS (REWRITE) (EQUAL (PLUS X Y) (PLUS Y X)))
WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma ASSOCIATIVITY-OF-PLUS could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma PLUS-RIGHT-ID2 could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma PLUS-NON-NUMBERP could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma PLUS-ADD1 could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma PLUS-1 could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the previously added lemma PLUS-0 could.




This formula simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA COMMUTATIVITY2-OF-PLUS (REWRITE) (EQUAL (PLUS X (PLUS Y Z)) (PLUS Y (PLUS X Z))))
WARNING:  the previously added lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the newly proposed COMMUTATIVITY2-OF-PLUS could!


This simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA DIFFERENCE-PLUS-1 (REWRITE) (EQUAL (DIFFERENCE (PLUS X Y) X) (FIX Y)))
This conjecture simplifies, opening up the function FIX, to the following two
new goals:

Case 2. (IMPLIES (NOT (NUMBERP Y))
                 (EQUAL (DIFFERENCE (PLUS X Y) X) 0)).

  But this again simplifies, applying PLUS-RIGHT-ID2, to the following two new
  formulas:

  Case 2.2.
          (IMPLIES (AND (NOT (NUMBERP Y))
                        (NOT (NUMBERP X)))
                   (EQUAL (DIFFERENCE 0 X) 0)).

    However this again simplifies, unfolding the definitions of EQUAL and
    DIFFERENCE, to:

          T.

  Case 2.1.
          (IMPLIES (AND (NOT (NUMBERP Y)) (NUMBERP X))
                   (EQUAL (DIFFERENCE X X) 0)),

    which again simplifies, using linear arithmetic, to:

          (IMPLIES (AND (LESSP X X)
                        (NOT (NUMBERP Y))
                        (NUMBERP X))
                   (EQUAL (DIFFERENCE X X) 0)).

    This again simplifies, using linear arithmetic, to:

          T.

Case 1. (IMPLIES (NUMBERP Y)
                 (EQUAL (DIFFERENCE (PLUS X Y) X) Y)),

  which again simplifies, using linear arithmetic, to:

        (IMPLIES (AND (LESSP (PLUS X Y) X) (NUMBERP Y))
                 (EQUAL (DIFFERENCE (PLUS X Y) X) Y)).

  This again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA DIFFERENCE-PLUS-2 (REWRITE) (EQUAL (DIFFERENCE (PLUS Y X) X) (FIX Y)))
This conjecture simplifies, appealing to the lemmas COMMUTATIVITY-OF-PLUS and
DIFFERENCE-PLUS-1, and expanding the function FIX, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA DIFFERENCE-X-X (REWRITE) (EQUAL (DIFFERENCE X X) 0))
This conjecture simplifies, using linear arithmetic, to:

      (IMPLIES (LESSP X X)
               (EQUAL (DIFFERENCE X X) 0)).

But this again simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA EQUAL-DIFFERENCE-0 (REWRITE) (EQUAL (EQUAL 0 (DIFFERENCE X Y)) (NOT (LESSP Y X))))
This conjecture simplifies, unfolding NOT, to two new conjectures:

Case 2. (IMPLIES (NOT (EQUAL 0 (DIFFERENCE X Y)))
                 (LESSP Y X)),

  which we will name *1.

Case 1. (IMPLIES (EQUAL 0 (DIFFERENCE X Y))
                 (NOT (LESSP Y X))).

  But this again simplifies, using linear arithmetic, to:

        T.


     So next consider:

      (IMPLIES (NOT (EQUAL 0 (DIFFERENCE X Y)))
               (LESSP Y X)),

which we named *1 above.  We will try to prove it by induction.  There are
four plausible inductions.  However, they merge into one likely candidate
induction.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p Y X))
           (IMPLIES (AND (NOT (ZEROP X)) (ZEROP Y))
                    (p Y X))
           (IMPLIES (AND (NOT (ZEROP X))
                         (NOT (ZEROP Y))
                         (p (SUB1 Y) (SUB1 X)))
                    (p Y X))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP can be
used to establish that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  Note,
however, the inductive instance chosen for Y.  The above induction scheme
leads to the following four new goals:

Case 4. (IMPLIES (AND (ZEROP X)
                      (NOT (EQUAL 0 (DIFFERENCE X Y))))
                 (LESSP Y X)).

  This simplifies, expanding the functions ZEROP, EQUAL, and DIFFERENCE, to:

        T.

Case 3. (IMPLIES (AND (NOT (ZEROP X))
                      (ZEROP Y)
                      (NOT (EQUAL 0 (DIFFERENCE X Y))))
                 (LESSP Y X)).

  This simplifies, opening up ZEROP, EQUAL, DIFFERENCE, and LESSP, to:

        T.

Case 2. (IMPLIES (AND (NOT (ZEROP X))
                      (NOT (ZEROP Y))
                      (EQUAL 0
                             (DIFFERENCE (SUB1 X) (SUB1 Y)))
                      (NOT (EQUAL 0 (DIFFERENCE X Y))))
                 (LESSP Y X)).

  This simplifies, using linear arithmetic, to the following three new goals:

  Case 2.3.
          (IMPLIES (AND (LESSP (SUB1 X) (SUB1 Y))
                        (NOT (ZEROP X))
                        (NOT (ZEROP Y))
                        (EQUAL 0
                               (DIFFERENCE (SUB1 X) (SUB1 Y)))
                        (NOT (EQUAL 0 (DIFFERENCE X Y))))
                   (LESSP Y X)).

    But this again simplifies, unfolding the functions ZEROP, DIFFERENCE, and
    EQUAL, to:

          T.

  Case 2.2.
          (IMPLIES (AND (LESSP X 1)
                        (NOT (ZEROP X))
                        (NOT (ZEROP Y))
                        (EQUAL 0
                               (DIFFERENCE (SUB1 X) (SUB1 Y)))
                        (NOT (EQUAL 0 (DIFFERENCE X Y))))
                   (LESSP Y X)),

    which again simplifies, unfolding SUB1, NUMBERP, EQUAL, LESSP, and ZEROP,
    to:

          T.

  Case 2.1.
          (IMPLIES (AND (LESSP X Y)
                        (NOT (ZEROP X))
                        (NOT (ZEROP Y))
                        (EQUAL 0
                               (DIFFERENCE (SUB1 X) (SUB1 Y)))
                        (NOT (EQUAL 0 (DIFFERENCE X Y))))
                   (LESSP Y X)),

    which again simplifies, using linear arithmetic, to two new conjectures:

    Case 2.1.2.
            (IMPLIES (AND (LESSP (SUB1 X) (SUB1 Y))
                          (LESSP X Y)
                          (NOT (ZEROP X))
                          (NOT (ZEROP Y))
                          (EQUAL 0
                                 (DIFFERENCE (SUB1 X) (SUB1 Y)))
                          (NOT (EQUAL 0 (DIFFERENCE X Y))))
                     (LESSP Y X)),

      which again simplifies, opening up the definitions of LESSP, ZEROP,
      DIFFERENCE, and EQUAL, to:

            T.

    Case 2.1.1.
            (IMPLIES (AND (LESSP X 1)
                          (LESSP X Y)
                          (NOT (ZEROP X))
                          (NOT (ZEROP Y))
                          (EQUAL 0
                                 (DIFFERENCE (SUB1 X) (SUB1 Y)))
                          (NOT (EQUAL 0 (DIFFERENCE X Y))))
                     (LESSP Y X)),

      which again simplifies, unfolding SUB1, NUMBERP, EQUAL, LESSP, and ZEROP,
      to:

            T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (NOT (ZEROP Y))
                      (LESSP (SUB1 Y) (SUB1 X))
                      (NOT (EQUAL 0 (DIFFERENCE X Y))))
                 (LESSP Y X)),

  which simplifies, using linear arithmetic, to:

        (IMPLIES (AND (LESSP X 1)
                      (NOT (ZEROP X))
                      (NOT (ZEROP Y))
                      (LESSP (SUB1 Y) (SUB1 X))
                      (NOT (EQUAL 0 (DIFFERENCE X Y))))
                 (LESSP Y X)).

  However this again simplifies, expanding SUB1, NUMBERP, EQUAL, LESSP, and
  ZEROP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA EQUAL-TIMES-0 (REWRITE) (EQUAL (EQUAL (TIMES X Y) 0) (OR (ZEROP X) (ZEROP Y))))
This simplifies, opening up the functions ZEROP and OR, to five new
conjectures:

Case 5. (IMPLIES (NOT (EQUAL (TIMES X Y) 0))
                 (NUMBERP Y)),

  which we will name *1.

Case 4. (IMPLIES (NOT (EQUAL (TIMES X Y) 0))
                 (NOT (EQUAL Y 0))).

  This again simplifies, trivially, to the new formula:

        (EQUAL (TIMES X 0) 0),

  which we would normally push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us return to:

(EQUAL (EQUAL (TIMES X Y) 0)
       (OR (ZEROP X) (ZEROP Y))).

We named this *1.  We will try to prove it by induction.  There is only one
suggested induction.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y))
                    (p X Y))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP inform
us that the measure (COUNT X) decreases according to the well-founded relation
LESSP in each induction step of the scheme.  The above induction scheme
generates two new conjectures:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (EQUAL (TIMES X Y) 0)
                        (OR (ZEROP X) (ZEROP Y)))),

  which simplifies, expanding ZEROP, EQUAL, TIMES, and OR, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (EQUAL (TIMES (SUB1 X) Y) 0)
                             (OR (ZEROP (SUB1 X)) (ZEROP Y))))
                 (EQUAL (EQUAL (TIMES X Y) 0)
                        (OR (ZEROP X) (ZEROP Y)))),

  which simplifies, applying the lemmas PLUS-EQUAL-0, COMMUTATIVITY-OF-PLUS,
  and PLUS-RIGHT-ID2, and opening up the functions ZEROP, OR, TIMES, EQUAL,
  PLUS, and NUMBERP, to:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (EQUAL (TIMES (SUB1 X) Y) 0)
                      (EQUAL Y 0))
                 (EQUAL (TIMES (SUB1 X) 0) 0)).

  This again simplifies, trivially, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-DIFFERENCE-1 (REWRITE) (IMPLIES (AND (NUMBERP V) (NUMBERP Y) (NUMBERP Z) (NOT (LESSP Z V)) (NOT (LESSP Y V))) (EQUAL (LESSP (DIFFERENCE Y V) (DIFFERENCE Z V)) (LESSP Y Z))))
This simplifies, applying EQUAL-LESSP, to the following two new formulas:

Case 2. (IMPLIES (AND (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (LESSP Z V))
                      (NOT (LESSP Y V))
                      (NOT (LESSP (DIFFERENCE Y V)
                                  (DIFFERENCE Z V))))
                 (NOT (LESSP Y Z))).

  But this again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (LESSP Z V))
                      (NOT (LESSP Y V))
                      (LESSP (DIFFERENCE Y V)
                             (DIFFERENCE Z V)))
                 (LESSP Y Z)),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-DIFFERENCE-2 (REWRITE) (IMPLIES (AND (NUMBERP V) (NUMBERP Y) (NUMBERP Z) (LESSP Z V) (LESSP Y V)) (EQUAL (LESSP (DIFFERENCE V Z) (DIFFERENCE V Y)) (LESSP Y Z))))
This formula simplifies, rewriting with EQUAL-LESSP, to the following two new
conjectures:

Case 2. (IMPLIES (AND (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (LESSP Z V)
                      (LESSP Y V)
                      (NOT (LESSP (DIFFERENCE V Z)
                                  (DIFFERENCE V Y))))
                 (NOT (LESSP Y Z))).

  This again simplifies, using linear arithmetic, to:

        (IMPLIES (AND (LESSP V Z)
                      (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (LESSP Z V)
                      (LESSP Y V)
                      (NOT (LESSP (DIFFERENCE V Z)
                                  (DIFFERENCE V Y))))
                 (NOT (LESSP Y Z))).

  However this again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (LESSP Z V)
                      (LESSP Y V)
                      (LESSP (DIFFERENCE V Z)
                             (DIFFERENCE V Y)))
                 (LESSP Y Z)),

  which again simplifies, using linear arithmetic, to:

        (IMPLIES (AND (LESSP V Y)
                      (NUMBERP V)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (LESSP Z V)
                      (LESSP Y V)
                      (LESSP (DIFFERENCE V Z)
                             (DIFFERENCE V Y)))
                 (LESSP Y Z)).

  This again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-DIFFERENCE-3 (REWRITE) (IMPLIES (AND (NUMBERP W) (NUMBERP V) (NUMBERP X) (NOT (LESSP X W)) (NOT (LESSP X V))) (EQUAL (LESSP (DIFFERENCE X V) (DIFFERENCE X W)) (LESSP W V))))
This simplifies, applying EQUAL-LESSP, to the following two new formulas:

Case 2. (IMPLIES (AND (NUMBERP W)
                      (NUMBERP V)
                      (NUMBERP X)
                      (NOT (LESSP X W))
                      (NOT (LESSP X V))
                      (NOT (LESSP (DIFFERENCE X V)
                                  (DIFFERENCE X W))))
                 (NOT (LESSP W V))).

  But this again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP W)
                      (NUMBERP V)
                      (NUMBERP X)
                      (NOT (LESSP X W))
                      (NOT (LESSP X V))
                      (LESSP (DIFFERENCE X V)
                             (DIFFERENCE X W)))
                 (LESSP W V)),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-PLUS-1 (REWRITE) (IMPLIES (AND (NUMBERP A) (NUMBERP B) (NUMBERP C)) (EQUAL (LESSP (PLUS A B) (PLUS A C)) (LESSP B C))))
This conjecture simplifies, rewriting with the lemma EQUAL-LESSP, to two new
goals:

Case 2. (IMPLIES (AND (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (LESSP (PLUS A B) (PLUS A C))))
                 (NOT (LESSP B C))),

  which again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (LESSP (PLUS A B) (PLUS A C)))
                 (LESSP B C)),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA TIMES-0 (REWRITE) (EQUAL (TIMES X 0) 0))
This conjecture can be simplified, using the abbreviation EQUAL-TIMES-0, to:

      (IMPLIES (AND (NOT (EQUAL X 0))
                    (NUMBERP X)
                    (NOT (EQUAL 0 0)))
               (NOT (NUMBERP 0))).

This simplifies, clearly, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA TIMES-ADD1 (REWRITE) (EQUAL (TIMES X (ADD1 Y)) (IF (NUMBERP Y) (PLUS X (TIMES X Y)) (FIX X))))
This conjecture simplifies, unfolding the definition of FIX, to three new
conjectures:

Case 3. (IMPLIES (AND (NOT (NUMBERP Y)) (NUMBERP X))
                 (EQUAL (TIMES X (ADD1 Y)) X)),

  which again simplifies, rewriting with SUB1-TYPE-RESTRICTION, to the new
  formula:

        (IMPLIES (AND (NOT (NUMBERP Y)) (NUMBERP X))
                 (EQUAL (TIMES X 1) X)),

  which we will name *1.

Case 2. (IMPLIES (AND (NOT (NUMBERP Y))
                      (NOT (NUMBERP X)))
                 (EQUAL (TIMES X (ADD1 Y)) 0)).

  However this again simplifies, applying SUB1-TYPE-RESTRICTION, and opening
  up the definitions of TIMES and EQUAL, to:

        T.

Case 1. (IMPLIES (NUMBERP Y)
                 (EQUAL (TIMES X (ADD1 Y))
                        (PLUS X (TIMES X Y)))),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(EQUAL (TIMES X (ADD1 Y))
       (IF (NUMBERP Y)
           (PLUS X (TIMES X Y))
           (FIX X))),

which we named *1 above.  We will appeal to induction.  The recursive terms in
the conjecture suggest three inductions.  However, they merge into one likely
candidate induction.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y))
                    (p X Y))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP
establish that the measure (COUNT X) decreases according to the well-founded
relation LESSP in each induction step of the scheme.  The above induction
scheme leads to the following two new formulas:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (TIMES X (ADD1 Y))
                        (IF (NUMBERP Y)
                            (PLUS X (TIMES X Y))
                            (FIX X)))).

  This simplifies, rewriting with PLUS-RIGHT-ID2 and COMMUTATIVITY-OF-PLUS,
  and expanding the definitions of ZEROP, EQUAL, TIMES, PLUS, FIX, and NUMBERP,
  to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (TIMES (SUB1 X) (ADD1 Y))
                             (IF (NUMBERP Y)
                                 (PLUS (SUB1 X) (TIMES (SUB1 X) Y))
                                 (FIX (SUB1 X)))))
                 (EQUAL (TIMES X (ADD1 Y))
                        (IF (NUMBERP Y)
                            (PLUS X (TIMES X Y))
                            (FIX X)))),

  which simplifies, applying SUB1-TYPE-RESTRICTION and SUB1-ADD1, and
  unfolding the functions ZEROP, FIX, TIMES, and PLUS, to the following two
  new formulas:

  Case 1.2.
          (IMPLIES (AND (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (NOT (NUMBERP Y))
                        (EQUAL (TIMES (SUB1 X) (ADD1 Y))
                               (SUB1 X)))
                   (EQUAL (TIMES X 1) X)).

    But this further simplifies, rewriting with SUB1-TYPE-RESTRICTION, PLUS-1,
    and ADD1-SUB1, and unfolding TIMES, to:

          T.

  Case 1.1.
          (IMPLIES (AND (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (NUMBERP Y)
                        (EQUAL (TIMES (SUB1 X) (ADD1 Y))
                               (PLUS (SUB1 X) (TIMES (SUB1 X) Y))))
                   (EQUAL (ADD1 (PLUS Y (TIMES (SUB1 X) (ADD1 Y))))
                          (PLUS X Y (TIMES (SUB1 X) Y)))).

    However this again simplifies, using linear arithmetic, to:

          T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA TIMES-NON-NUMBERP (REWRITE) (IMPLIES (NOT (NUMBERP Y)) (EQUAL (TIMES X Y) 0)))
This formula can be simplified, using the abbreviations EQUAL-TIMES-0, NOT,
and IMPLIES, to:

      T,

which simplifies, trivially, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA TIMES-ZERO (REWRITE) (EQUAL (TIMES X 0) 0))
WARNING:  the previously added lemma, TIMES-0, could be applied whenever the
newly proposed TIMES-ZERO could!


This conjecture can be simplified, using the abbreviation TIMES-0, to:

      (EQUAL 0 0).

This simplifies, clearly, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA X-NOT-LESS-THAN-X (REWRITE) (EQUAL (LESSP X X) F))
This conjecture simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA ZERO-DIFFERENCE (REWRITE) (IMPLIES (LESSP A B) (EQUAL (DIFFERENCE A B) 0)))
This conjecture can be simplified, using the abbreviations EQUAL-DIFFERENCE-0
and IMPLIES, to:

      (IMPLIES (LESSP A B)
               (NOT (LESSP B A))).

This simplifies, using linear arithmetic, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA ASSOCIATIVITY-OF-TIMES (REWRITE) (EQUAL (TIMES (TIMES X Y) Z) (TIMES X (TIMES Y Z))))

     Call the conjecture *1.


     Perhaps we can prove it by induction.  Three inductions are suggested by
terms in the conjecture.  They merge into two likely candidate inductions.
However, only one is unflawed.  We will induct according to the following
scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP can be
used to prove that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme leads to two new goals:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (TIMES (TIMES X Y) Z)
                        (TIMES X Y Z))),

  which simplifies, opening up the definitions of ZEROP, EQUAL, and TIMES, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (TIMES (TIMES (SUB1 X) Y) Z)
                             (TIMES (SUB1 X) Y Z)))
                 (EQUAL (TIMES (TIMES X Y) Z)
                        (TIMES X Y Z))),

  which simplifies, expanding ZEROP and TIMES, to:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (EQUAL (TIMES (TIMES (SUB1 X) Y) Z)
                             (TIMES (SUB1 X) Y Z)))
                 (EQUAL (TIMES (PLUS Y (TIMES (SUB1 X) Y)) Z)
                        (PLUS (TIMES Y Z)
                              (TIMES (SUB1 X) Y Z)))).

  Appealing to the lemma SUB1-ELIM, we now replace X by (ADD1 V) to eliminate
  (SUB1 X).  We rely upon the type restriction lemma noted when SUB1 was
  introduced to constrain the new variable.  This generates:

        (IMPLIES (AND (NUMBERP V)
                      (NOT (EQUAL (ADD1 V) 0))
                      (EQUAL (TIMES (TIMES V Y) Z)
                             (TIMES V Y Z)))
                 (EQUAL (TIMES (PLUS Y (TIMES V Y)) Z)
                        (PLUS (TIMES Y Z) (TIMES V Y Z)))).

  This further simplifies, trivially, to:

        (IMPLIES (AND (NUMBERP V)
                      (EQUAL (TIMES (TIMES V Y) Z)
                             (TIMES V Y Z)))
                 (EQUAL (TIMES (PLUS Y (TIMES V Y)) Z)
                        (PLUS (TIMES Y Z) (TIMES V Y Z)))).

  We use the above equality hypothesis by substituting (TIMES (TIMES V Y) Z)
  for (TIMES V Y Z) and throwing away the equality.  This generates the goal:

        (IMPLIES (NUMBERP V)
                 (EQUAL (TIMES (PLUS Y (TIMES V Y)) Z)
                        (PLUS (TIMES Y Z)
                              (TIMES (TIMES V Y) Z)))).

  We will try to prove the above formula by generalizing it, replacing
  (TIMES V Y) by A.  We restrict the new variable by recalling the type
  restriction lemma noted when TIMES was introduced.  We thus obtain:

        (IMPLIES (AND (NUMBERP A) (NUMBERP V))
                 (EQUAL (TIMES (PLUS Y A) Z)
                        (PLUS (TIMES Y Z) (TIMES A Z)))),

  which further simplifies, applying COMMUTATIVITY-OF-PLUS, to:

        (IMPLIES (AND (NUMBERP A) (NUMBERP V))
                 (EQUAL (TIMES (PLUS A Y) Z)
                        (PLUS (TIMES A Z) (TIMES Y Z)))),

  which has an irrelevant term in it.  By eliminating the term we get:

        (IMPLIES (NUMBERP A)
                 (EQUAL (TIMES (PLUS A Y) Z)
                        (PLUS (TIMES A Z) (TIMES Y Z)))),

  which we will finally name *1.1.


     Perhaps we can prove it by induction.  The recursive terms in the
conjecture suggest three inductions.  They merge into two likely candidate
inductions.  However, only one is unflawed.  We will induct according to the
following scheme:
      (AND (IMPLIES (ZEROP A) (p A Y Z))
           (IMPLIES (AND (NOT (ZEROP A)) (p (SUB1 A) Y Z))
                    (p A Y Z))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definition
of ZEROP establish that the measure (COUNT A) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme generates the following two new formulas:

Case 2. (IMPLIES (AND (ZEROP A) (NUMBERP A))
                 (EQUAL (TIMES (PLUS A Y) Z)
                        (PLUS (TIMES A Z) (TIMES Y Z)))).

  This simplifies, expanding the functions ZEROP, NUMBERP, EQUAL, PLUS, and
  TIMES, to the new conjecture:

        (IMPLIES (AND (EQUAL A 0) (NOT (NUMBERP Y)))
                 (EQUAL (TIMES 0 Z) (TIMES Y Z))),

  which again simplifies, expanding EQUAL and TIMES, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP A))
                      (EQUAL (TIMES (PLUS (SUB1 A) Y) Z)
                             (PLUS (TIMES (SUB1 A) Z) (TIMES Y Z)))
                      (NUMBERP A))
                 (EQUAL (TIMES (PLUS A Y) Z)
                        (PLUS (TIMES A Z) (TIMES Y Z)))),

  which simplifies, appealing to the lemmas COMMUTATIVITY-OF-PLUS, SUB1-ADD1,
  and COMMUTATIVITY2-OF-PLUS, and opening up the definitions of ZEROP, PLUS,
  and TIMES, to:

        T.


     That finishes the proof of *1.1, which, consequently, finishes the proof
of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA COMMUTATIVITY-OF-TIMES (REWRITE) (EQUAL (TIMES X Y) (TIMES Y X)))
WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the previously added lemma ASSOCIATIVITY-OF-TIMES could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the previously added lemma TIMES-ZERO could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the previously added lemma TIMES-NON-NUMBERP could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the previously added lemma TIMES-ADD1 could.




WARNING:  the newly proposed lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the previously added lemma TIMES-0 could.





     Give the conjecture the name *1.


     We will appeal to induction.  Two inductions are suggested by terms in
the conjecture, both of which are flawed.  We limit our consideration to the
two suggested by the largest number of nonprimitive recursive functions in the
conjecture.  Since both of these are equally likely, we will choose
arbitrarily.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y))
                    (p X Y))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP inform
us that the measure (COUNT X) decreases according to the well-founded relation
LESSP in each induction step of the scheme.  The above induction scheme
produces the following two new conjectures:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (TIMES X Y) (TIMES Y X))).

  This simplifies, applying TIMES-ZERO and TIMES-NON-NUMBERP, and opening up
  the functions ZEROP, EQUAL, and TIMES, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (TIMES (SUB1 X) Y)
                             (TIMES Y (SUB1 X))))
                 (EQUAL (TIMES X Y) (TIMES Y X))),

  which simplifies, unfolding the functions ZEROP and TIMES, to:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (EQUAL (TIMES (SUB1 X) Y)
                             (TIMES Y (SUB1 X))))
                 (EQUAL (PLUS Y (TIMES Y (SUB1 X)))
                        (TIMES Y X))).

  Appealing to the lemma SUB1-ELIM, we now replace X by (ADD1 Z) to eliminate
  (SUB1 X).  We employ the type restriction lemma noted when SUB1 was
  introduced to constrain the new variable.  We must thus prove:

        (IMPLIES (AND (NUMBERP Z)
                      (NOT (EQUAL (ADD1 Z) 0))
                      (EQUAL (TIMES Z Y) (TIMES Y Z)))
                 (EQUAL (PLUS Y (TIMES Y Z))
                        (TIMES Y (ADD1 Z)))).

  However this further simplifies, applying the lemma TIMES-ADD1, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA COMMUTATIVITY2-OF-TIMES (REWRITE) (EQUAL (TIMES X (TIMES Y Z)) (TIMES Y (TIMES X Z))))
WARNING:  the previously added lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the newly proposed COMMUTATIVITY2-OF-TIMES could!



     Call the conjecture *1.


     Perhaps we can prove it by induction.  Four inductions are suggested by
terms in the conjecture.  They merge into two likely candidate inductions,
both of which are unflawed.  Since both of these are equally likely, we will
choose arbitrarily.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP Y) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP Y)) (p X (SUB1 Y) Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP can be
used to prove that the measure (COUNT Y) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme leads to two new goals:

Case 2. (IMPLIES (ZEROP Y)
                 (EQUAL (TIMES X Y Z) (TIMES Y X Z))),

  which simplifies, applying the lemma COMMUTATIVITY-OF-TIMES, and opening up
  the definitions of ZEROP, EQUAL, and TIMES, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP Y))
                      (EQUAL (TIMES X (SUB1 Y) Z)
                             (TIMES (SUB1 Y) X Z)))
                 (EQUAL (TIMES X Y Z) (TIMES Y X Z))),

  which simplifies, unfolding the functions ZEROP and TIMES, to the goal:

        (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (EQUAL (TIMES X (SUB1 Y) Z)
                             (TIMES (SUB1 Y) X Z)))
                 (EQUAL (TIMES X (PLUS Z (TIMES (SUB1 Y) Z)))
                        (PLUS (TIMES X Z)
                              (TIMES X (SUB1 Y) Z)))).

  However this further simplifies, applying the lemma COMMUTATIVITY-OF-TIMES,
  to the conjecture:

        (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (EQUAL (TIMES X Z (SUB1 Y))
                             (TIMES (SUB1 Y) X Z)))
                 (EQUAL (TIMES X (PLUS Z (TIMES Z (SUB1 Y))))
                        (PLUS (TIMES X Z)
                              (TIMES X Z (SUB1 Y))))).

  Appealing to the lemma SUB1-ELIM, we now replace Y by (ADD1 V) to eliminate
  (SUB1 Y).  We rely upon the type restriction lemma noted when SUB1 was
  introduced to constrain the new variable.  We must thus prove:

        (IMPLIES (AND (NUMBERP V)
                      (NOT (EQUAL (ADD1 V) 0))
                      (EQUAL (TIMES X Z V) (TIMES V X Z)))
                 (EQUAL (TIMES X (PLUS Z (TIMES Z V)))
                        (PLUS (TIMES X Z) (TIMES X Z V)))).

  But this further simplifies, applying COMMUTATIVITY-OF-TIMES, to:

        (IMPLIES (AND (NUMBERP V)
                      (EQUAL (TIMES X V Z) (TIMES V X Z)))
                 (EQUAL (TIMES X (PLUS Z (TIMES V Z)))
                        (PLUS (TIMES X Z) (TIMES V X Z)))).

  We use the above equality hypothesis by substituting (TIMES X V Z) for
  (TIMES V X Z) and throwing away the equality.  We must thus prove:

        (IMPLIES (NUMBERP V)
                 (EQUAL (TIMES X (PLUS Z (TIMES V Z)))
                        (PLUS (TIMES X Z) (TIMES X V Z)))).

  We will try to prove the above formula by generalizing it, replacing
  (TIMES V Z) by A.  We restrict the new variable by recalling the type
  restriction lemma noted when TIMES was introduced.  This produces:

        (IMPLIES (AND (NUMBERP A) (NUMBERP V))
                 (EQUAL (TIMES X (PLUS Z A))
                        (PLUS (TIMES X Z) (TIMES X A)))),

  which further simplifies, rewriting with COMMUTATIVITY-OF-PLUS and
  COMMUTATIVITY-OF-TIMES, to:

        (IMPLIES (AND (NUMBERP A) (NUMBERP V))
                 (EQUAL (TIMES X (PLUS A Z))
                        (PLUS (TIMES A X) (TIMES X Z)))),

  which has an irrelevant term in it.  By eliminating the term we get:

        (IMPLIES (NUMBERP A)
                 (EQUAL (TIMES X (PLUS A Z))
                        (PLUS (TIMES A X) (TIMES X Z)))),

  which we will finally name *1.1.


     We will appeal to induction.  There are four plausible inductions.  They
merge into two likely candidate inductions.  However, only one is unflawed.
We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP A) (p X A Z))
           (IMPLIES (AND (NOT (ZEROP A)) (p X (SUB1 A) Z))
                    (p X A Z))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definition
of ZEROP establish that the measure (COUNT A) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme leads to the following two new conjectures:

Case 2. (IMPLIES (AND (ZEROP A) (NUMBERP A))
                 (EQUAL (TIMES X (PLUS A Z))
                        (PLUS (TIMES A X) (TIMES X Z)))).

  This simplifies, expanding the functions ZEROP, NUMBERP, EQUAL, PLUS, and
  TIMES, to the new conjecture:

        (IMPLIES (AND (EQUAL A 0) (NOT (NUMBERP Z)))
                 (EQUAL (TIMES X 0) (TIMES X Z))),

  which again simplifies, applying COMMUTATIVITY-OF-TIMES and
  TIMES-NON-NUMBERP, and unfolding EQUAL and TIMES, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP A))
                      (EQUAL (TIMES X (PLUS (SUB1 A) Z))
                             (PLUS (TIMES (SUB1 A) X) (TIMES X Z)))
                      (NUMBERP A))
                 (EQUAL (TIMES X (PLUS A Z))
                        (PLUS (TIMES A X) (TIMES X Z)))).

  This simplifies, applying COMMUTATIVITY-OF-PLUS, TIMES-ADD1, and
  COMMUTATIVITY2-OF-PLUS, and opening up the definitions of ZEROP, PLUS, and
  TIMES, to:

        T.


     That finishes the proof of *1.1, which, in turn, finishes the proof of *1.
Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA DISTRIBUTIVITY-OF-TIMES-OVER-DIFFERENCE (REWRITE) (EQUAL (TIMES X (DIFFERENCE Y Z)) (DIFFERENCE (TIMES X Y) (TIMES X Z))))
WARNING:  the previously added lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the newly proposed DISTRIBUTIVITY-OF-TIMES-OVER-DIFFERENCE could!



     Call the conjecture *1.


     We will try to prove it by induction.  There are five plausible
inductions.  They merge into two likely candidate inductions.  However, only
one is unflawed.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP inform
us that the measure (COUNT X) decreases according to the well-founded relation
LESSP in each induction step of the scheme.  The above induction scheme
generates two new goals:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (TIMES X (DIFFERENCE Y Z))
                        (DIFFERENCE (TIMES X Y)
                                    (TIMES X Z)))),

  which simplifies, opening up the functions ZEROP, EQUAL, TIMES, and
  DIFFERENCE, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                             (DIFFERENCE (TIMES (SUB1 X) Y)
                                         (TIMES (SUB1 X) Z))))
                 (EQUAL (TIMES X (DIFFERENCE Y Z))
                        (DIFFERENCE (TIMES X Y)
                                    (TIMES X Z)))),

  which simplifies, expanding ZEROP and TIMES, to the conjecture:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                             (DIFFERENCE (TIMES (SUB1 X) Y)
                                         (TIMES (SUB1 X) Z))))
                 (EQUAL (PLUS (DIFFERENCE Y Z)
                              (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                        (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                    (PLUS Z (TIMES (SUB1 X) Z))))).

  But this again simplifies, using linear arithmetic, to three new conjectures:

  Case 1.3.
          (IMPLIES (AND (LESSP (TIMES (SUB1 X) Y)
                               (TIMES (SUB1 X) Z))
                        (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                               (DIFFERENCE (TIMES (SUB1 X) Y)
                                           (TIMES (SUB1 X) Z))))
                   (EQUAL (PLUS (DIFFERENCE Y Z)
                                (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                          (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                      (PLUS Z (TIMES (SUB1 X) Z))))),

    which again simplifies, applying ZERO-DIFFERENCE, EQUAL-DIFFERENCE-0, and
    EQUAL-TIMES-0, and unfolding PLUS, to the following two new goals:

    Case 1.3.2.
            (IMPLIES (AND (LESSP (TIMES (SUB1 X) Y)
                                 (TIMES (SUB1 X) Z))
                          (NOT (EQUAL X 0))
                          (NUMBERP X)
                          (EQUAL (SUB1 X) 0))
                     (EQUAL (PLUS (DIFFERENCE Y Z)
                                  (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                            (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                        (PLUS Z (TIMES (SUB1 X) Z))))).

      But this again simplifies, using linear arithmetic, to two new goals:

      Case 1.3.2.2.
              (IMPLIES (AND (LESSP Y Z)
                            (LESSP (TIMES 0 Y) (TIMES 0 Z))
                            (NOT (EQUAL X 0))
                            (NUMBERP X)
                            (EQUAL (SUB1 X) 0))
                       (EQUAL (PLUS (DIFFERENCE Y Z)
                                    (TIMES 0 (DIFFERENCE Y Z)))
                              (DIFFERENCE (PLUS Y (TIMES 0 Y))
                                          (PLUS Z (TIMES 0 Z))))),

        which again simplifies, using linear arithmetic, to:

              T.

      Case 1.3.2.1.
              (IMPLIES (AND (LESSP (PLUS Y (TIMES 0 Y))
                                   (PLUS Z (TIMES 0 Z)))
                            (LESSP (TIMES 0 Y) (TIMES 0 Z))
                            (NOT (EQUAL X 0))
                            (NUMBERP X)
                            (EQUAL (SUB1 X) 0))
                       (EQUAL (PLUS (DIFFERENCE Y Z)
                                    (TIMES 0 (DIFFERENCE Y Z)))
                              (DIFFERENCE (PLUS Y (TIMES 0 Y))
                                          (PLUS Z (TIMES 0 Z))))),

        which again simplifies, using linear arithmetic, to:

              T.

    Case 1.3.1.
            (IMPLIES (AND (LESSP (TIMES (SUB1 X) Y)
                                 (TIMES (SUB1 X) Z))
                          (NOT (EQUAL X 0))
                          (NUMBERP X)
                          (NOT (LESSP Z Y)))
                     (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                            (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                        (PLUS Z (TIMES (SUB1 X) Z))))),

      which again simplifies, using linear arithmetic and applying the lemmas
      ZERO-DIFFERENCE, EQUAL-DIFFERENCE-0, and EQUAL-TIMES-0, to:

            T.

  Case 1.2.
          (IMPLIES (AND (LESSP Y Z)
                        (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                               (DIFFERENCE (TIMES (SUB1 X) Y)
                                           (TIMES (SUB1 X) Z))))
                   (EQUAL (PLUS (DIFFERENCE Y Z)
                                (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                          (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                      (PLUS Z (TIMES (SUB1 X) Z))))),

    which again simplifies, applying ZERO-DIFFERENCE, and expanding the
    functions EQUAL and PLUS, to:

          (IMPLIES (AND (LESSP Y Z)
                        (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                               (DIFFERENCE (TIMES (SUB1 X) Y)
                                           (TIMES (SUB1 X) Z))))
                   (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                          (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                      (PLUS Z (TIMES (SUB1 X) Z))))),

    which further simplifies, applying ZERO-DIFFERENCE, COMMUTATIVITY-OF-TIMES,
    and EQUAL-DIFFERENCE-0, and unfolding the definitions of EQUAL and TIMES,
    to:

          (IMPLIES (AND (LESSP Y Z)
                        (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (NOT (LESSP (TIMES Z (SUB1 X))
                                    (TIMES Y (SUB1 X)))))
                   (NOT (LESSP (PLUS Z (TIMES Z (SUB1 X)))
                               (PLUS Y (TIMES Y (SUB1 X)))))),

    which again simplifies, using linear arithmetic, to:

          T.

  Case 1.1.
          (IMPLIES (AND (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                               (PLUS Z (TIMES (SUB1 X) Z)))
                        (NOT (EQUAL X 0))
                        (NUMBERP X)
                        (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                               (DIFFERENCE (TIMES (SUB1 X) Y)
                                           (TIMES (SUB1 X) Z))))
                   (EQUAL (PLUS (DIFFERENCE Y Z)
                                (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                          (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                      (PLUS Z (TIMES (SUB1 X) Z))))),

    which again simplifies, using linear arithmetic, applying ZERO-DIFFERENCE,
    EQUAL-DIFFERENCE-0, and EQUAL-TIMES-0, and unfolding EQUAL and PLUS, to
    the following two new formulas:

    Case 1.1.2.
            (IMPLIES (AND (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                                 (PLUS Z (TIMES (SUB1 X) Z)))
                          (NOT (EQUAL X 0))
                          (NUMBERP X)
                          (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                                 (DIFFERENCE (TIMES (SUB1 X) Y)
                                             (TIMES (SUB1 X) Z)))
                          (LESSP (TIMES (SUB1 X) Y)
                                 (TIMES (SUB1 X) Z)))
                     (EQUAL (PLUS (DIFFERENCE Y Z)
                                  (TIMES (SUB1 X) (DIFFERENCE Y Z)))
                            (DIFFERENCE (PLUS Y (TIMES (SUB1 X) Y))
                                        (PLUS Z (TIMES (SUB1 X) Z))))).

      But this again simplifies, applying the lemmas ZERO-DIFFERENCE,
      EQUAL-DIFFERENCE-0, and EQUAL-TIMES-0, and unfolding the functions EQUAL,
      LESSP, and PLUS, to:

            T.

    Case 1.1.1.
            (IMPLIES (AND (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                                 (PLUS Z (TIMES (SUB1 X) Z)))
                          (NOT (EQUAL X 0))
                          (NUMBERP X)
                          (EQUAL (TIMES (SUB1 X) (DIFFERENCE Y Z))
                                 (DIFFERENCE (TIMES (SUB1 X) Y)
                                             (TIMES (SUB1 X) Z)))
                          (NOT (LESSP (TIMES (SUB1 X) Y)
                                      (TIMES (SUB1 X) Z)))
                          (NOT (EQUAL (SUB1 X) 0)))
                     (NOT (LESSP Z Y))),

      which again simplifies, using linear arithmetic, to:

            T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA DISTRIBUTIVITY-OF-TIMES-OVER-PLUS (REWRITE) (EQUAL (TIMES X (PLUS Y Z)) (PLUS (TIMES X Y) (TIMES X Z))))
WARNING:  the previously added lemma, COMMUTATIVITY-OF-TIMES, could be applied
whenever the newly proposed DISTRIBUTIVITY-OF-TIMES-OVER-PLUS could!



     Call the conjecture *1.


     We will try to prove it by induction.  There are four plausible
inductions.  They merge into two likely candidate inductions.  However, only
one is unflawed.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP inform
us that the measure (COUNT X) decreases according to the well-founded relation
LESSP in each induction step of the scheme.  The above induction scheme
generates two new goals:

Case 2. (IMPLIES (ZEROP X)
                 (EQUAL (TIMES X (PLUS Y Z))
                        (PLUS (TIMES X Y) (TIMES X Z)))),

  which simplifies, opening up the functions ZEROP, EQUAL, TIMES, and PLUS, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (TIMES (SUB1 X) (PLUS Y Z))
                             (PLUS (TIMES (SUB1 X) Y)
                                   (TIMES (SUB1 X) Z))))
                 (EQUAL (TIMES X (PLUS Y Z))
                        (PLUS (TIMES X Y) (TIMES X Z)))),

  which simplifies, applying ASSOCIATIVITY-OF-PLUS, COMMUTATIVITY-OF-PLUS, and
  COMMUTATIVITY2-OF-PLUS, and unfolding the functions ZEROP and TIMES, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-TIMES (REWRITE) (IMPLIES (AND (NUMBERP X) (NUMBERP Y) (NUMBERP Z) (NOT (LESSP Y Z))) (EQUAL (LESSP (TIMES X Y) (TIMES X Z)) F)))

     Give the conjecture the name *1.


     We will appeal to induction.  There are four plausible inductions.  They
merge into two likely candidate inductions.  However, only one is unflawed.
We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP
establish that the measure (COUNT X) decreases according to the well-founded
relation LESSP in each induction step of the scheme.  The above induction
scheme generates the following two new formulas:

Case 2. (IMPLIES (AND (ZEROP X)
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (LESSP Y Z)))
                 (NOT (LESSP (TIMES X Y) (TIMES X Z)))).

  This simplifies, unfolding ZEROP, NUMBERP, EQUAL, TIMES, and LESSP, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (NOT (LESSP (TIMES (SUB1 X) Y)
                                  (TIMES (SUB1 X) Z)))
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (LESSP Y Z)))
                 (NOT (LESSP (TIMES X Y) (TIMES X Z)))).

  This simplifies, opening up the definitions of ZEROP and TIMES, to:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (NOT (LESSP (TIMES (SUB1 X) Y)
                                  (TIMES (SUB1 X) Z)))
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (LESSP Y Z)))
                 (NOT (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                             (PLUS Z (TIMES (SUB1 X) Z))))),

  which again simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-TIMES-1 (REWRITE) (IMPLIES (AND (NUMBERP X) (NUMBERP Y) (NUMBERP Z) (NOT (ZEROP X))) (EQUAL (NOT (LESSP (TIMES X Y) (TIMES X Z))) (NOT (LESSP Y Z)))))
WARNING:  Note that the rewrite rule MONOTONICITY-OF-TIMES-1 will be stored so
as to apply only to terms with the nonrecursive function symbol NOT.


This formula can be simplified, using the abbreviations ZEROP, NOT, AND, and
IMPLIES, to:

      (IMPLIES (AND (NUMBERP X)
                    (NUMBERP Y)
                    (NUMBERP Z)
                    (NOT (EQUAL X 0)))
               (EQUAL (NOT (LESSP (TIMES X Y) (TIMES X Z)))
                      (NOT (LESSP Y Z)))),

which simplifies, expanding the definition of NOT, to two new conjectures:

Case 2. (IMPLIES (AND (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (NOT (LESSP Y Z)))
                 (NOT (LESSP (TIMES X Y) (TIMES X Z)))),

  which again simplifies, appealing to the lemma MONOTONICITY-OF-TIMES, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (TIMES X Y) (TIMES X Z))),

  which we will name *1.


     We will appeal to induction.  There are four plausible inductions.  They
merge into two likely candidate inductions.  However, only one is unflawed.
We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y Z))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y Z))
                    (p X Y Z))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP
establish that the measure (COUNT X) decreases according to the well-founded
relation LESSP in each induction step of the scheme.  The above induction
scheme leads to the following three new conjectures:

Case 3. (IMPLIES (AND (ZEROP X)
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (TIMES X Y) (TIMES X Z))).

  This simplifies, expanding the function ZEROP, to:

        T.

Case 2. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (SUB1 X) 0)
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (TIMES X Y) (TIMES X Z))).

  This simplifies, unfolding the definitions of ZEROP and TIMES, to the new
  goal:

        (IMPLIES (AND (EQUAL (SUB1 X) 0)
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                        (PLUS Z (TIMES (SUB1 X) Z)))),

  which again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (LESSP (TIMES (SUB1 X) Y)
                             (TIMES (SUB1 X) Z))
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (TIMES X Y) (TIMES X Z))),

  which simplifies, opening up the definitions of ZEROP and TIMES, to the
  formula:

        (IMPLIES (AND (LESSP (TIMES (SUB1 X) Y)
                             (TIMES (SUB1 X) Z))
                      (NUMBERP X)
                      (NUMBERP Y)
                      (NUMBERP Z)
                      (NOT (EQUAL X 0))
                      (LESSP Y Z))
                 (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                        (PLUS Z (TIMES (SUB1 X) Z)))).

  This again simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-TIMES-3 (REWRITE) (IMPLIES (AND (NUMBERP A) (NUMBERP B) (NUMBERP C) (NOT (EQUAL C 0))) (EQUAL (LESSP (TIMES C A) (TIMES C B)) (LESSP A B))))
This simplifies, applying COMMUTATIVITY-OF-TIMES and EQUAL-LESSP, to the
following two new goals:

Case 2. (IMPLIES (AND (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0))
                      (NOT (LESSP (TIMES A C) (TIMES B C))))
                 (NOT (LESSP A B))).

  Name the above subgoal *1.

Case 1. (IMPLIES (AND (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0))
                      (LESSP (TIMES A C) (TIMES B C)))
                 (LESSP A B)),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(IMPLIES (AND (NUMBERP A)
              (NUMBERP B)
              (NUMBERP C)
              (NOT (EQUAL C 0)))
         (EQUAL (LESSP (TIMES C A) (TIMES C B))
                (LESSP A B))).

We gave this the name *1 above.  Perhaps we can prove it by induction.  There
are four plausible inductions.  They merge into two likely candidate
inductions.  However, only one is unflawed.  We will induct according to the
following scheme:
      (AND (IMPLIES (ZEROP C) (p C A B))
           (IMPLIES (AND (NOT (ZEROP C)) (p (SUB1 C) A B))
                    (p C A B))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP can be
used to prove that the measure (COUNT C) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme leads to three new conjectures:

Case 3. (IMPLIES (AND (ZEROP C)
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (EQUAL (LESSP (TIMES C A) (TIMES C B))
                        (LESSP A B))),

  which simplifies, opening up ZEROP, to:

        T.

Case 2. (IMPLIES (AND (NOT (ZEROP C))
                      (EQUAL (SUB1 C) 0)
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (EQUAL (LESSP (TIMES C A) (TIMES C B))
                        (LESSP A B))),

  which simplifies, rewriting with the lemmas COMMUTATIVITY-OF-TIMES and
  EQUAL-LESSP, and expanding the definition of ZEROP, to two new conjectures:

  Case 2.2.
          (IMPLIES (AND (EQUAL (SUB1 C) 0)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0))
                        (NOT (LESSP (TIMES A C) (TIMES B C))))
                   (NOT (LESSP A B))).

    Applying the lemma SUB1-ELIM, replace C by (ADD1 X) to eliminate (SUB1 C).
    We use the type restriction lemma noted when SUB1 was introduced to
    restrict the new variable.  We would thus like to prove the new formula:

          (IMPLIES (AND (NUMBERP X)
                        (EQUAL X 0)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NOT (EQUAL (ADD1 X) 0))
                        (NOT (LESSP (TIMES A (ADD1 X))
                                    (TIMES B (ADD1 X)))))
                   (NOT (LESSP A B))),

    which further simplifies, appealing to the lemmas COMMUTATIVITY-OF-PLUS
    and COMMUTATIVITY-OF-TIMES, and unfolding the definitions of NUMBERP,
    EQUAL, SUB1, TIMES, and PLUS, to:

          T.

  Case 2.1.
          (IMPLIES (AND (EQUAL (SUB1 C) 0)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0))
                        (LESSP (TIMES A C) (TIMES B C)))
                   (LESSP A B)).

    Applying the lemma SUB1-ELIM, replace C by (ADD1 X) to eliminate (SUB1 C).
    We rely upon the type restriction lemma noted when SUB1 was introduced to
    restrict the new variable.  We thus obtain the new formula:

          (IMPLIES (AND (NUMBERP X)
                        (EQUAL X 0)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NOT (EQUAL (ADD1 X) 0))
                        (LESSP (TIMES A (ADD1 X))
                               (TIMES B (ADD1 X))))
                   (LESSP A B)),

    which further simplifies, rewriting with COMMUTATIVITY-OF-PLUS and
    COMMUTATIVITY-OF-TIMES, and unfolding the functions NUMBERP, EQUAL, SUB1,
    TIMES, and PLUS, to:

          T.

Case 1. (IMPLIES (AND (NOT (ZEROP C))
                      (EQUAL (LESSP (TIMES (SUB1 C) A)
                                    (TIMES (SUB1 C) B))
                             (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (EQUAL (LESSP (TIMES C A) (TIMES C B))
                        (LESSP A B))).

  This simplifies, applying EQUAL-LESSP and COMMUTATIVITY-OF-TIMES, and
  expanding ZEROP, to two new formulas:

  Case 1.2.
          (IMPLIES (AND (NOT (LESSP (TIMES (SUB1 C) A)
                                    (TIMES (SUB1 C) B)))
                        (NOT (LESSP A B))
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0)))
                   (NOT (LESSP (TIMES A C) (TIMES B C)))),

    which again simplifies, applying the lemma MONOTONICITY-OF-TIMES, to the
    goal:

          (IMPLIES (AND (NOT (LESSP A B))
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0)))
                   (NOT (LESSP (TIMES A C) (TIMES B C)))).

    Call the above conjecture *1.1.

  Case 1.1.
          (IMPLIES (AND (LESSP (TIMES (SUB1 C) A)
                               (TIMES (SUB1 C) B))
                        (LESSP A B)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0)))
                   (LESSP (TIMES A C) (TIMES B C))).

    However this further simplifies, applying COMMUTATIVITY-OF-TIMES, to the
    new goal:

          (IMPLIES (AND (LESSP (TIMES A (SUB1 C))
                               (TIMES B (SUB1 C)))
                        (LESSP A B)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NUMBERP C)
                        (NOT (EQUAL C 0)))
                   (LESSP (TIMES A C) (TIMES B C))).

    Applying the lemma SUB1-ELIM, replace C by (ADD1 X) to eliminate (SUB1 C).
    We employ the type restriction lemma noted when SUB1 was introduced to
    restrict the new variable.  We thus obtain:

          (IMPLIES (AND (NUMBERP X)
                        (LESSP (TIMES A X) (TIMES B X))
                        (LESSP A B)
                        (NUMBERP A)
                        (NUMBERP B)
                        (NOT (EQUAL (ADD1 X) 0)))
                   (LESSP (TIMES A (ADD1 X))
                          (TIMES B (ADD1 X)))),

    which further simplifies, applying TIMES-ADD1, to:

          (IMPLIES (AND (NUMBERP X)
                        (LESSP (TIMES A X) (TIMES B X))
                        (LESSP A B)
                        (NUMBERP A)
                        (NUMBERP B))
                   (LESSP (PLUS A (TIMES A X))
                          (PLUS B (TIMES B X)))),

    which again simplifies, using linear arithmetic, to:

          T.


     So we now return to:

      (IMPLIES (AND (NOT (LESSP A B))
                    (NUMBERP A)
                    (NUMBERP B)
                    (NUMBERP C)
                    (NOT (EQUAL C 0)))
               (NOT (LESSP (TIMES A C) (TIMES B C)))),

which we named *1.1 above.  Let us appeal to the induction principle.  The
recursive terms in the conjecture suggest four inductions.  However, they
merge into one likely candidate induction.  We will induct according to the
following scheme:
      (AND (IMPLIES (OR (EQUAL B 0) (NOT (NUMBERP B)))
                    (p A C B))
           (IMPLIES (AND (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                         (OR (EQUAL A 0) (NOT (NUMBERP A))))
                    (p A C B))
           (IMPLIES (AND (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                         (NOT (OR (EQUAL A 0) (NOT (NUMBERP A))))
                         (p (SUB1 A) C (SUB1 B)))
                    (p A C B))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definitions
of OR and NOT can be used to establish that the measure (COUNT A) decreases
according to the well-founded relation LESSP in each induction step of the
scheme.  Note, however, the inductive instance chosen for B.  The above
induction scheme leads to the following four new conjectures:

Case 4. (IMPLIES (AND (OR (EQUAL B 0) (NOT (NUMBERP B)))
                      (NOT (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (NOT (LESSP (TIMES A C) (TIMES B C)))).

  This simplifies, expanding the definitions of NOT, OR, EQUAL, LESSP, NUMBERP,
  and TIMES, to:

        T.

Case 3. (IMPLIES (AND (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                      (OR (EQUAL A 0) (NOT (NUMBERP A)))
                      (NOT (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (NOT (LESSP (TIMES A C) (TIMES B C)))).

  This simplifies, expanding the definitions of NOT, OR, EQUAL, and LESSP, to:

        T.

Case 2. (IMPLIES (AND (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                      (NOT (OR (EQUAL A 0) (NOT (NUMBERP A))))
                      (LESSP (SUB1 A) (SUB1 B))
                      (NOT (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (NOT (LESSP (TIMES A C) (TIMES B C)))).

  This simplifies, using linear arithmetic, to:

        (IMPLIES (AND (EQUAL B 0)
                      (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                      (NOT (OR (EQUAL A 0) (NOT (NUMBERP A))))
                      (LESSP (SUB1 A) (SUB1 B))
                      (NOT (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (NOT (LESSP (TIMES A C) (TIMES B C)))),

  which again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NOT (OR (EQUAL B 0) (NOT (NUMBERP B))))
                      (NOT (OR (EQUAL A 0) (NOT (NUMBERP A))))
                      (NOT (LESSP (TIMES (SUB1 A) C)
                                  (TIMES (SUB1 B) C)))
                      (NOT (LESSP A B))
                      (NUMBERP A)
                      (NUMBERP B)
                      (NUMBERP C)
                      (NOT (EQUAL C 0)))
                 (NOT (LESSP (TIMES A C) (TIMES B C)))),

  which simplifies, rewriting with the lemma MONOTONICITY-OF-PLUS-1, and
  expanding NOT, OR, LESSP, and TIMES, to:

        T.


     That finishes the proof of *1.1, which, consequently, finishes the proof
of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA MONOTONICITY-OF-TIMES-BY-TWOS (REWRITE) (IMPLIES (AND (LESSP X Y) (LESSP Z W)) (LESSP (TIMES X Z) (TIMES Y W))))
WARNING:  When the linear lemma MONOTONICITY-OF-TIMES-BY-TWOS is stored under
(TIMES Y W) it contains the free variables Z and X which will be chosen by
instantiating the hypotheses (LESSP X Y) and (LESSP Z W).


WARNING:  When the linear lemma MONOTONICITY-OF-TIMES-BY-TWOS is stored under
(TIMES X Z) it contains the free variables W and Y which will be chosen by
instantiating the hypotheses (LESSP X Y) and (LESSP Z W).


WARNING:  Note that the proposed lemma MONOTONICITY-OF-TIMES-BY-TWOS is to be
stored as zero type prescription rules, zero compound recognizer rules, two
linear rules, and zero replacement rules.


This simplifies, rewriting with COMMUTATIVITY-OF-TIMES, to the formula:

      (IMPLIES (AND (LESSP X Y) (LESSP Z W))
               (LESSP (TIMES X Z) (TIMES W Y))).

Give the above formula the name *1.


     Perhaps we can prove it by induction.  There are six plausible inductions.
They merge into two likely candidate inductions, both of which are flawed.  We
limit our consideration to the two suggested by the largest number of
nonprimitive recursive functions in the conjecture.  Since both of these are
equally likely, we will choose arbitrarily.  We will induct according to the
following scheme:
      (AND (IMPLIES (OR (EQUAL Y 0) (NOT (NUMBERP Y)))
                    (p X Z W Y))
           (IMPLIES (AND (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                         (OR (EQUAL X 0) (NOT (NUMBERP X))))
                    (p X Z W Y))
           (IMPLIES (AND (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                         (NOT (OR (EQUAL X 0) (NOT (NUMBERP X))))
                         (p (SUB1 X) Z W (SUB1 Y)))
                    (p X Z W Y))).
Linear arithmetic, the lemmas SUB1-LESSEQP and SUB1-LESSP, and the definitions
of OR and NOT inform us that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  Note,
however, the inductive instance chosen for Y.  The above induction scheme
generates the following four new goals:

Case 4. (IMPLIES (AND (OR (EQUAL Y 0) (NOT (NUMBERP Y)))
                      (LESSP X Y)
                      (LESSP Z W))
                 (LESSP (TIMES X Z) (TIMES W Y))).

  This simplifies, expanding NOT, OR, EQUAL, and LESSP, to:

        T.

Case 3. (IMPLIES (AND (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                      (OR (EQUAL X 0) (NOT (NUMBERP X)))
                      (LESSP X Y)
                      (LESSP Z W))
                 (LESSP (TIMES X Z) (TIMES W Y))).

  This simplifies, applying EQUAL-TIMES-0, and expanding the definitions of
  NOT, OR, EQUAL, LESSP, and TIMES, to four new conjectures:

  Case 3.4.
          (IMPLIES (AND (NOT (EQUAL Y 0))
                        (NUMBERP Y)
                        (EQUAL X 0)
                        (LESSP Z W))
                   (NOT (EQUAL W 0))),

    which again simplifies, using linear arithmetic, to:

          T.

  Case 3.3.
          (IMPLIES (AND (NOT (EQUAL Y 0))
                        (NUMBERP Y)
                        (EQUAL X 0)
                        (LESSP Z W))
                   (NUMBERP W)),

    which again simplifies, opening up the function LESSP, to:

          T.

  Case 3.2.
          (IMPLIES (AND (NOT (EQUAL Y 0))
                        (NUMBERP Y)
                        (NOT (NUMBERP X))
                        (LESSP Z W))
                   (NOT (EQUAL W 0))),

    which again simplifies, using linear arithmetic, to:

          T.

  Case 3.1.
          (IMPLIES (AND (NOT (EQUAL Y 0))
                        (NUMBERP Y)
                        (NOT (NUMBERP X))
                        (LESSP Z W))
                   (NUMBERP W)),

    which again simplifies, opening up LESSP, to:

          T.

Case 2. (IMPLIES (AND (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                      (NOT (OR (EQUAL X 0) (NOT (NUMBERP X))))
                      (NOT (LESSP (SUB1 X) (SUB1 Y)))
                      (LESSP X Y)
                      (LESSP Z W))
                 (LESSP (TIMES X Z) (TIMES W Y))),

  which simplifies, using linear arithmetic, to the goal:

        (IMPLIES (AND (LESSP X 1)
                      (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                      (NOT (OR (EQUAL X 0) (NOT (NUMBERP X))))
                      (NOT (LESSP (SUB1 X) (SUB1 Y)))
                      (LESSP X Y)
                      (LESSP Z W))
                 (LESSP (TIMES X Z) (TIMES W Y))).

  This again simplifies, opening up the functions SUB1, NUMBERP, EQUAL, LESSP,
  NOT, and OR, to:

        T.

Case 1. (IMPLIES (AND (NOT (OR (EQUAL Y 0) (NOT (NUMBERP Y))))
                      (NOT (OR (EQUAL X 0) (NOT (NUMBERP X))))
                      (LESSP (TIMES (SUB1 X) Z)
                             (TIMES W (SUB1 Y)))
                      (LESSP X Y)
                      (LESSP Z W))
                 (LESSP (TIMES X Z) (TIMES W Y))),

  which simplifies, unfolding NOT, OR, LESSP, and TIMES, to:

        (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (LESSP (TIMES (SUB1 X) Z)
                             (TIMES W (SUB1 Y)))
                      (LESSP (SUB1 X) (SUB1 Y))
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES (SUB1 X) Z))
                        (TIMES W Y))).

  However this further simplifies, applying COMMUTATIVITY-OF-TIMES, to:

        (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NOT (EQUAL X 0))
                      (NUMBERP X)
                      (LESSP (TIMES Z (SUB1 X))
                             (TIMES W (SUB1 Y)))
                      (LESSP (SUB1 X) (SUB1 Y))
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES Z (SUB1 X)))
                        (TIMES W Y))).

  Applying the lemma SUB1-ELIM, replace X by (ADD1 V) to eliminate (SUB1 X).
  We employ the type restriction lemma noted when SUB1 was introduced to
  restrict the new variable.  We would thus like to prove:

        (IMPLIES (AND (NUMBERP V)
                      (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NOT (EQUAL (ADD1 V) 0))
                      (LESSP (TIMES Z V) (TIMES W (SUB1 Y)))
                      (LESSP V (SUB1 Y))
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES Z V))
                        (TIMES W Y))),

  which further simplifies, rewriting with COMMUTATIVITY-OF-TIMES, to:

        (IMPLIES (AND (NUMBERP V)
                      (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (LESSP (TIMES V Z) (TIMES W (SUB1 Y)))
                      (LESSP V (SUB1 Y))
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES V Z))
                        (TIMES W Y))).

  Applying the lemma SUB1-ELIM, replace Y by (ADD1 D) to eliminate (SUB1 Y).
  We use the type restriction lemma noted when SUB1 was introduced to restrict
  the new variable.  We thus obtain:

        (IMPLIES (AND (NUMBERP D)
                      (NUMBERP V)
                      (NOT (EQUAL (ADD1 D) 0))
                      (LESSP (TIMES V Z) (TIMES W D))
                      (LESSP V D)
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES V Z))
                        (TIMES W (ADD1 D)))),

  which further simplifies, applying COMMUTATIVITY-OF-TIMES and TIMES-ADD1, to:

        (IMPLIES (AND (NUMBERP D)
                      (NUMBERP V)
                      (LESSP (TIMES V Z) (TIMES D W))
                      (LESSP V D)
                      (LESSP Z W))
                 (LESSP (PLUS Z (TIMES V Z))
                        (PLUS W (TIMES D W)))),

  which finally simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA QUOTIENT-TIMES (REWRITE) (EQUAL (QUOTIENT (TIMES Y X) Y) (IF (ZEROP Y) 0 (FIX X))))
This conjecture simplifies, applying COMMUTATIVITY-OF-TIMES, and expanding the
functions ZEROP and FIX, to four new conjectures:

Case 4. (IMPLIES (EQUAL Y 0)
                 (EQUAL (QUOTIENT (TIMES X Y) Y) 0)),

  which again simplifies, applying COMMUTATIVITY-OF-TIMES, and opening up
  EQUAL, TIMES, and QUOTIENT, to:

        T.

Case 3. (IMPLIES (NOT (NUMBERP Y))
                 (EQUAL (QUOTIENT (TIMES X Y) Y) 0)).

  This again simplifies, applying TIMES-NON-NUMBERP, and opening up the
  functions QUOTIENT and EQUAL, to:

        T.

Case 2. (IMPLIES (NOT (NUMBERP X))
                 (EQUAL (QUOTIENT (TIMES X Y) Y) 0)).

  However this again simplifies, unfolding the definitions of TIMES, LESSP,
  EQUAL, and QUOTIENT, to:

        T.

Case 1. (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NUMBERP X))
                 (EQUAL (QUOTIENT (TIMES X Y) Y) X)),

  which we will name *1.


     We will appeal to induction.  There is only one plausible induction.  We
will induct according to the following scheme:
      (AND (IMPLIES (ZEROP X) (p X Y))
           (IMPLIES (AND (NOT (ZEROP X)) (p (SUB1 X) Y))
                    (p X Y))).
Linear arithmetic, the lemma COUNT-NUMBERP, and the definition of ZEROP can be
used to establish that the measure (COUNT X) decreases according to the
well-founded relation LESSP in each induction step of the scheme.  The above
induction scheme generates two new goals:

Case 2. (IMPLIES (AND (ZEROP X)
                      (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NUMBERP X))
                 (EQUAL (QUOTIENT (TIMES X Y) Y) X)),

  which simplifies, opening up ZEROP, NUMBERP, EQUAL, TIMES, LESSP, and
  QUOTIENT, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP X))
                      (EQUAL (QUOTIENT (TIMES (SUB1 X) Y) Y)
                             (SUB1 X))
                      (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NUMBERP X))
                 (EQUAL (QUOTIENT (TIMES X Y) Y) X)),

  which simplifies, rewriting with ADD1-SUB1 and DIFFERENCE-PLUS-1, and
  expanding the functions ZEROP, TIMES, and QUOTIENT, to the new formula:

        (IMPLIES (AND (NOT (EQUAL X 0))
                      (EQUAL (QUOTIENT (TIMES (SUB1 X) Y) Y)
                             (SUB1 X))
                      (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NUMBERP X))
                 (NOT (LESSP (PLUS Y (TIMES (SUB1 X) Y))
                             Y))),

  which again simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA REMAINDER-NON-NUMERIC (REWRITE) (IMPLIES (NOT (NUMBERP X)) (EQUAL (REMAINDER Y X) (FIX Y))))
This simplifies, unfolding the definitions of REMAINDER and FIX, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA REMAINDER-QUOTIENT (REWRITE) (EQUAL (PLUS (REMAINDER X Y) (TIMES Y (QUOTIENT X Y))) (FIX X)))
WARNING:  the previously added lemma, COMMUTATIVITY-OF-PLUS, could be applied
whenever the newly proposed REMAINDER-QUOTIENT could!


This formula simplifies, opening up the function FIX, to the following two new
goals:

Case 2. (IMPLIES (NOT (NUMBERP X))
                 (EQUAL (PLUS (REMAINDER X Y)
                              (TIMES Y (QUOTIENT X Y)))
                        0)).

  However this again simplifies, rewriting with COMMUTATIVITY-OF-TIMES, and
  opening up LESSP, REMAINDER, QUOTIENT, EQUAL, TIMES, and PLUS, to:

        T.

Case 1. (IMPLIES (NUMBERP X)
                 (EQUAL (PLUS (REMAINDER X Y)
                              (TIMES Y (QUOTIENT X Y)))
                        X)).

  Call the above conjecture *1.


     We will appeal to induction.  Three inductions are suggested by terms in
the conjecture.  They merge into two likely candidate inductions.  However,
only one is unflawed.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP Y) (p X Y))
           (IMPLIES (AND (NOT (ZEROP Y)) (LESSP X Y))
                    (p X Y))
           (IMPLIES (AND (NOT (ZEROP Y))
                         (NOT (LESSP X Y))
                         (p (DIFFERENCE X Y) Y))
                    (p X Y))).
Linear arithmetic, the lemmas COUNT-NUMBERP and COUNT-NOT-LESSP, and the
definition of ZEROP can be used to show that the measure (COUNT X) decreases
according to the well-founded relation LESSP in each induction step of the
scheme.  The above induction scheme produces three new goals:

Case 3. (IMPLIES (AND (ZEROP Y) (NUMBERP X))
                 (EQUAL (PLUS (REMAINDER X Y)
                              (TIMES Y (QUOTIENT X Y)))
                        X)),

  which simplifies, applying COMMUTATIVITY-OF-PLUS, REMAINDER-NON-NUMERIC,
  TIMES-NON-NUMBERP, and COMMUTATIVITY-OF-TIMES, and unfolding the functions
  ZEROP, EQUAL, REMAINDER, QUOTIENT, TIMES, and PLUS, to:

        T.

Case 2. (IMPLIES (AND (NOT (ZEROP Y))
                      (LESSP X Y)
                      (NUMBERP X))
                 (EQUAL (PLUS (REMAINDER X Y)
                              (TIMES Y (QUOTIENT X Y)))
                        X)).

  This simplifies, rewriting with the lemmas COMMUTATIVITY-OF-TIMES and
  COMMUTATIVITY-OF-PLUS, and opening up the functions ZEROP, REMAINDER,
  QUOTIENT, EQUAL, TIMES, and PLUS, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP Y))
                      (NOT (LESSP X Y))
                      (EQUAL (PLUS (REMAINDER (DIFFERENCE X Y) Y)
                                   (TIMES Y
                                          (QUOTIENT (DIFFERENCE X Y) Y)))
                             (DIFFERENCE X Y))
                      (NUMBERP X))
                 (EQUAL (PLUS (REMAINDER X Y)
                              (TIMES Y (QUOTIENT X Y)))
                        X)).

  This simplifies, rewriting with TIMES-ADD1 and COMMUTATIVITY2-OF-PLUS, and
  opening up the functions ZEROP, REMAINDER, and QUOTIENT, to the goal:

        (IMPLIES (AND (NOT (EQUAL Y 0))
                      (NUMBERP Y)
                      (NOT (LESSP X Y))
                      (EQUAL (PLUS (REMAINDER (DIFFERENCE X Y) Y)
                                   (TIMES Y
                                          (QUOTIENT (DIFFERENCE X Y) Y)))
                             (DIFFERENCE X Y))
                      (NUMBERP X))
                 (EQUAL (PLUS Y (DIFFERENCE X Y)) X)).

  But this again simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA REMAINDER-QUOTIENT-ELIM (ELIM) (IMPLIES (AND (NOT (ZEROP Y)) (NUMBERP X)) (EQUAL (PLUS (REMAINDER X Y) (TIMES Y (QUOTIENT X Y))) X)))
This formula can be simplified, using the abbreviations ZEROP, NOT, AND, and
IMPLIES, to:

      (IMPLIES (AND (NOT (EQUAL Y 0))
                    (NUMBERP Y)
                    (NUMBERP X))
               (EQUAL (PLUS (REMAINDER X Y)
                            (TIMES Y (QUOTIENT X Y)))
                      X)),

which simplifies, rewriting with REMAINDER-QUOTIENT, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA REMAINDER-WRT-1 (REWRITE) (EQUAL (REMAINDER Y 1) 0))
.

Appealing to the lemma REMAINDER-QUOTIENT-ELIM, we now replace Y by
(PLUS X (TIMES 1 Z)) to eliminate (REMAINDER Y 1) and (QUOTIENT Y 1).  We
employ the type restriction lemma noted when REMAINDER was introduced and the
type restriction lemma noted when QUOTIENT was introduced to constrain the new
variables.  We must thus prove four new formulas:

Case 4. (IMPLIES (NOT (NUMBERP Y))
                 (EQUAL (REMAINDER Y 1) 0)),

  which simplifies, expanding the definitions of LESSP, NUMBERP, EQUAL, and
  REMAINDER, to:

        T.

Case 3. (IMPLIES (EQUAL 1 0)
                 (EQUAL (REMAINDER Y 1) 0)),

  which simplifies, using linear arithmetic, to:

        T.

Case 2. (IMPLIES (NOT (NUMBERP 1))
                 (EQUAL (REMAINDER Y 1) 0)),

  which simplifies, trivially, to:

        T.

Case 1. (IMPLIES (AND (NUMBERP X)
                      (NUMBERP Z)
                      (NOT (EQUAL 1 0)))
                 (EQUAL X 0)).

  However this simplifies, expanding EQUAL, to:

        (IMPLIES (AND (NUMBERP X) (NUMBERP Z))
                 (EQUAL X 0)),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(EQUAL (REMAINDER Y 1) 0),

which we named *1 above.  We will appeal to induction.  There is only one
plausible induction.  We will induct according to the following scheme:
      (AND (IMPLIES (ZEROP 1) (p Y))
           (IMPLIES (AND (NOT (ZEROP 1)) (LESSP Y 1))
                    (p Y))
           (IMPLIES (AND (NOT (ZEROP 1))
                         (NOT (LESSP Y 1))
                         (p (DIFFERENCE Y 1)))
                    (p Y))).
Linear arithmetic, the lemmas COUNT-NUMBERP and COUNT-NOT-LESSP, and the
definition of ZEROP inform us that the measure (COUNT Y) decreases according
to the well-founded relation LESSP in each induction step of the scheme.  The
above induction scheme produces the following three new goals:

Case 3. (IMPLIES (ZEROP 1)
                 (EQUAL (REMAINDER Y 1) 0)).

  This simplifies, expanding the definition of ZEROP, to:

        T.

Case 2. (IMPLIES (AND (NOT (ZEROP 1)) (LESSP Y 1))
                 (EQUAL (REMAINDER Y 1) 0)).

  This simplifies, opening up the definitions of ZEROP, REMAINDER, EQUAL, and
  NUMBERP, to the new conjecture:

        (IMPLIES (AND (LESSP Y 1) (NUMBERP Y))
                 (EQUAL Y 0)),

  which again simplifies, using linear arithmetic, to:

        T.

Case 1. (IMPLIES (AND (NOT (ZEROP 1))
                      (NOT (LESSP Y 1))
                      (EQUAL (REMAINDER (DIFFERENCE Y 1) 1)
                             0))
                 (EQUAL (REMAINDER Y 1) 0)),

  which simplifies, opening up ZEROP, REMAINDER, EQUAL, and NUMBERP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA REMAINDER-X-X (REWRITE) (EQUAL (REMAINDER X X) 0))
This conjecture simplifies, rewriting with DIFFERENCE-X-X and
X-NOT-LESS-THAN-X, and expanding the functions NUMBERP, REMAINDER, LESSP, and
EQUAL, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(ADD-SHELL UNDEFINED-OBJECT UNDEFINED UNDEFINEDP ())
[ 0.0 0.0 0.0 ]

(ADD-SHELL array-shell empty-array array-recognizer ((array-elt-value (NONE-OF) UNDEFINED) (array-elt-subscript (ONE-OF NUMBERP) ZERO) (array-prev (ONE-OF array-recognizer) empty-array)))
[ 0.0 0.0 0.0 ]

(DEFN DIFF-PLUS-1 (X Y) (DIFFERENCE (ADD1 Y) X))
     Note that (NUMBERP (DIFF-PLUS-1 X Y)) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN NEGATIVE-AND-NON-ZEROP (X) (IF (NEGATIVEP X) (IF (NOT (ZEROP (NEGATIVE-GUTS X))) T F) F))
     Note that:
      (OR (FALSEP (NEGATIVE-AND-NON-ZEROP X))
          (TRUEP (NEGATIVE-AND-NON-ZEROP X)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN POSITIVEP (X) (IF (NUMBERP X) (IF (NOT (ZEROP X)) T F) F))
     From the definition we can conclude that:
      (OR (FALSEP (POSITIVEP X))
          (TRUEP (POSITIVEP X)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN SIGN (X) (IF (NUMBERP X) 1 (IF (NEGATIVEP X) -1 0)))
     From the definition we can conclude that:
      (OR (NUMBERP (SIGN X))
          (NEGATIVEP (SIGN X)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN SIGN-MULT (X Y) (IF (EQUAL X 1) Y (IF (EQUAL Y 1) -1 1)))
     From the definition we can conclude that:
      (OR (OR (NUMBERP (SIGN-MULT X Y))
              (NEGATIVEP (SIGN-MULT X Y)))
          (EQUAL (SIGN-MULT X Y) Y))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN ZABS (X) (IF (NEGATIVEP X) (NEGATIVE-GUTS X) X))
     Note that (OR (NUMBERP (ZABS X)) (EQUAL (ZABS X) X)) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN ZNORMALIZE (X) (IF (NEGATIVEP X) (IF (EQUAL (NEGATIVE-GUTS X) 0) 0 X) X))
     Note that:
      (OR (OR (NUMBERP (ZNORMALIZE X))
              (NEGATIVEP (ZNORMALIZE X)))
          (EQUAL (ZNORMALIZE X) X))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN ZMONUS (X) (ZNORMALIZE (MINUS X)))
     From the definition we can conclude that:
      (OR (NUMBERP (ZMONUS X))
          (NEGATIVEP (ZMONUS X)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN booleanp (X) (OR (EQUAL X (TRUE)) (EQUAL X (FALSE))))
     Observe that (OR (FALSEP (BOOLEANP X)) (TRUEP (BOOLEANP X))) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN integerp (X) (IF (NUMBERP X) T (IF (NEGATIVEP X) (IF (ZEROP (NEGATIVE-GUTS X)) F T) F)))
     Note that (OR (FALSEP (INTEGERP X)) (TRUEP (INTEGERP X))) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN negi (X) (IF (integerp X) (IF (NEGATIVEP X) (NEGATIVE-GUTS X) (ZMONUS X)) 0))
     From the definition we can conclude that:
      (OR (NUMBERP (NEGI X))
          (NEGATIVEP (NEGI X)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN SWITCH (S X) (IF (EQUAL S 1) X (negi X)))
     From the definition we can conclude that:
      (OR (OR (NUMBERP (SWITCH S X))
              (NEGATIVEP (SWITCH S X)))
          (EQUAL (SWITCH S X) X))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN addi (X Y) (IF (NEGATIVEP X) (IF (NEGATIVEP Y) (ZMONUS (PLUS (NEGATIVE-GUTS X) (NEGATIVE-GUTS Y))) (IF (LESSP Y (NEGATIVE-GUTS X)) (ZMONUS (DIFFERENCE (NEGATIVE-GUTS X) Y)) (DIFFERENCE Y (NEGATIVE-GUTS X)))) (IF (NEGATIVEP Y) (IF (LESSP X (NEGATIVE-GUTS Y)) (ZMONUS (DIFFERENCE (NEGATIVE-GUTS Y) X)) (DIFFERENCE X (NEGATIVE-GUTS Y))) (PLUS X Y))))
     From the definition we can conclude that:
      (OR (NUMBERP (ADDI X Y))
          (NEGATIVEP (ADDI X Y)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN subi (X Y) (addi X (negi Y)))
     Note that (OR (NUMBERP (SUBI X Y)) (NEGATIVEP (SUBI X Y))) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN muli (X Y) (IF (NEGATIVEP X) (IF (NEGATIVEP Y) (TIMES (NEGATIVE-GUTS X) (NEGATIVE-GUTS Y)) (ZMONUS (TIMES (NEGATIVE-GUTS X) Y))) (IF (NEGATIVEP Y) (ZMONUS (TIMES X (NEGATIVE-GUTS Y))) (TIMES X Y))))
     From the definition we can conclude that:
      (OR (NUMBERP (MULI X Y))
          (NEGATIVEP (MULI X Y)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN divi (X Y) (IF (NEGATIVEP X) (IF (NEGATIVEP Y) (QUOTIENT (NEGATIVE-GUTS X) (NEGATIVE-GUTS Y)) (ZMONUS (QUOTIENT (NEGATIVE-GUTS X) Y))) (IF (NEGATIVEP Y) (ZMONUS (QUOTIENT X (NEGATIVE-GUTS Y))) (QUOTIENT X Y))))
     From the definition we can conclude that:
      (OR (NUMBERP (DIVI X Y))
          (NEGATIVEP (DIVI X Y)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN lti (X Y) (IF (NEGATIVEP X) (IF (NEGATIVEP Y) (LESSP (NEGATIVE-GUTS Y) (NEGATIVE-GUTS X)) (NOT (AND (EQUAL (NEGATIVE-GUTS X) 0) (ZEROP Y)))) (IF (NEGATIVEP Y) F (LESSP X Y))))
     From the definition we can conclude that:
      (OR (FALSEP (LTI X Y))
          (TRUEP (LTI X Y)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN gei (X Y) (NOT (lti X Y)))
     Note that (OR (FALSEP (GEI X Y)) (TRUEP (GEI X Y))) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN gti (X Y) (lti Y X))
     From the definition we can conclude that:
      (OR (FALSEP (GTI X Y))
          (TRUEP (GTI X Y)))
is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN lei (X Y) (NOT (lti Y X)))
     Note that (OR (FALSEP (LEI X Y)) (TRUEP (LEI X Y))) is a theorem.




[ 0.0 0.0 0.0 ]

(DEFN arrayp (A) (IF (array-recognizer A) (IF (EQUAL A (empty-array)) T (IF (OR (NOT (NUMBERP (array-elt-subscript A))) (EQUAL (array-elt-value A) (UNDEFINED))) F (IF (EQUAL (array-prev A) (empty-array)) T (AND (LESSP (array-elt-subscript (array-prev A)) (array-elt-subscript A)) (arrayp (array-prev A)))))) F))
     Linear arithmetic and the lemma ARRAY-PREV-LESSP can be used to prove
that the measure (COUNT A) decreases according to the well-founded relation
LESSP in each recursive call.  Hence, ARRAYP is accepted under the
definitional principle.  From the definition we can conclude that:
      (OR (FALSEP (ARRAYP A))
          (TRUEP (ARRAYP A)))
is a theorem.




[ 0.0 0.0 0.0 ]

(PROVE-LEMMA ARRAY-GETS-SMALLER (REWRITE) (IMPLIES (NOT (EQUAL (empty-array) (array-prev A))) (LESSP (COUNT (array-prev a)) (COUNT a))))
WARNING:  Note that the proposed lemma ARRAY-GETS-SMALLER is to be stored as
zero type prescription rules, zero compound recognizer rules, one linear rule,
and zero replacement rules.


This formula simplifies, using linear arithmetic and rewriting with the lemma
ARRAY-PREV-LESSEQP, to:

      (IMPLIES (AND (EQUAL (COUNT (ARRAY-PREV A))
                           (COUNT A))
                    (NOT (EQUAL (EMPTY-ARRAY) (ARRAY-PREV A))))
               (LESSP (COUNT A) (COUNT A))),

which again simplifies, applying X-NOT-LESS-THAN-X, to:

      (IMPLIES (EQUAL (COUNT (ARRAY-PREV A))
                      (COUNT A))
               (EQUAL (EMPTY-ARRAY) (ARRAY-PREV A))).

Applying the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
replace A by (ARRAY-SHELL V Z X) to eliminate (ARRAY-PREV A),
(ARRAY-ELT-SUBSCRIPT A), and (ARRAY-ELT-VALUE A).  We use the type restriction
lemma noted when ARRAY-PREV was introduced and the type restriction lemma
noted when ARRAY-ELT-SUBSCRIPT was introduced to restrict the new variables.
This produces the following three new goals:

Case 3. (IMPLIES (AND (EQUAL A (EMPTY-ARRAY))
                      (EQUAL (COUNT (ARRAY-PREV A))
                             (COUNT A)))
                 (EQUAL (EMPTY-ARRAY) (ARRAY-PREV A))).

  This further simplifies, opening up the functions ARRAY-PREV, COUNT, and
  EQUAL, to:

        T.

Case 2. (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                      (EQUAL (COUNT (ARRAY-PREV A))
                             (COUNT A)))
                 (EQUAL (EMPTY-ARRAY) (ARRAY-PREV A))),

  which further simplifies, rewriting with ARRAY-PREV-NARRAY-RECOGNIZER, and
  opening up COUNT and EQUAL, to:

        T.

Case 1. (IMPLIES (AND (ARRAY-RECOGNIZER X)
                      (NUMBERP Z)
                      (NOT (EQUAL (ARRAY-SHELL V Z X)
                                  (EMPTY-ARRAY)))
                      (EQUAL (COUNT X)
                             (COUNT (ARRAY-SHELL V Z X))))
                 (EQUAL (EMPTY-ARRAY) X)).

  This further simplifies, applying COUNT-NUMBERP, COMMUTATIVITY2-OF-PLUS, and
  COUNT-ARRAY-SHELL, to the new conjecture:

        (IMPLIES (AND (ARRAY-RECOGNIZER X)
                      (NUMBERP Z)
                      (EQUAL (COUNT X)
                             (ADD1 (PLUS Z (COUNT V) (COUNT X)))))
                 (EQUAL (EMPTY-ARRAY) X)),

  which again simplifies, using linear arithmetic, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(DEFN selecta (A I) (IF (EQUAL (array-elt-subscript A) I) (array-elt-value A) (IF (EQUAL (array-prev A) (empty-array)) (UNDEFINED) (selecta (array-prev A) I))))
     Linear arithmetic and the lemma ARRAY-GETS-SMALLER can be used to show
that the measure (COUNT A) decreases according to the well-founded relation
LESSP in each recursive call.  Hence, SELECTA is accepted under the
definitional principle.




[ 0.0 0.0 0.0 ]

(PROVE-LEMMA storea-is-sound (REWRITE) (implies (and (arrayp a) (not (equal a (empty-array)))) (lessp (count (array-prev a)) (count a))))
WARNING:  Note that the proposed lemma STOREA-IS-SOUND is to be stored as zero
type prescription rules, zero compound recognizer rules, one linear rule, and
zero replacement rules.


This simplifies, using linear arithmetic and applying ARRAY-PREV-LESSEQP, to:

      (IMPLIES (AND (EQUAL (COUNT (ARRAY-PREV A))
                           (COUNT A))
                    (ARRAYP A)
                    (NOT (EQUAL A (EMPTY-ARRAY))))
               (LESSP (COUNT A) (COUNT A))),

which again simplifies, rewriting with X-NOT-LESS-THAN-X, and expanding the
function ARRAYP, to the following two new goals:

Case 2. (IMPLIES (AND (EQUAL (COUNT (ARRAY-PREV A))
                             (COUNT A))
                      (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                  (UNDEFINED)))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                 (EQUAL A (EMPTY-ARRAY))).

  This again simplifies, opening up the definition of COUNT, to:

        (IMPLIES (AND (EQUAL 0 (COUNT A))
                      (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                  (UNDEFINED)))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                 (EQUAL A (EMPTY-ARRAY))).

  Appealing to the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
  we now replace A by (ARRAY-SHELL X V Z) to eliminate (ARRAY-ELT-VALUE A),
  (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A).  We use the type restriction
  lemma noted when ARRAY-PREV was introduced and the type restriction lemma
  noted when ARRAY-ELT-SUBSCRIPT was introduced to constrain the new variables.
  We must thus prove:

        (IMPLIES (AND (ARRAY-RECOGNIZER Z)
                      (NUMBERP V)
                      (EQUAL 0 (COUNT (ARRAY-SHELL X V Z)))
                      (NOT (EQUAL X (UNDEFINED)))
                      (EQUAL Z (EMPTY-ARRAY)))
                 (EQUAL (ARRAY-SHELL X V Z)
                        (EMPTY-ARRAY))).

  But this further simplifies, applying COUNT-NUMBERP, COMMUTATIVITY-OF-PLUS,
  and COUNT-ARRAY-SHELL, and opening up the definitions of ARRAY-RECOGNIZER,
  COUNT, EQUAL, and PLUS, to:

        T.

Case 1. (IMPLIES (AND (EQUAL (COUNT (ARRAY-PREV A))
                             (COUNT A))
                      (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                  (UNDEFINED)))
                      (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                             (ARRAY-ELT-SUBSCRIPT A))
                      (ARRAYP (ARRAY-PREV A)))
                 (EQUAL A (EMPTY-ARRAY))).

  But this again simplifies, using linear arithmetic and rewriting with
  ARRAY-PREV-LESSP, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(DEFN storea (A I V) (IF (NOT (arrayp A)) (empty-array) (IF (NOT (NUMBERP I)) A (IF (EQUAL A (empty-array)) (IF (EQUAL V (UNDEFINED)) (empty-array) (array-shell V I (empty-array))) (IF (EQUAL (array-elt-subscript A) I) (IF (EQUAL V (UNDEFINED)) (array-prev A) (array-shell V I (array-prev A))) (IF (LESSP (array-elt-subscript A) I) (IF (EQUAL V (UNDEFINED)) A (array-shell V I A)) (array-shell (array-elt-value A) (array-elt-subscript A) (storea (array-prev A) I V))))))))
     Linear arithmetic and the lemma STOREA-IS-SOUND establish that the
measure (COUNT A) decreases according to the well-founded relation LESSP in
each recursive call.  Hence, STOREA is accepted under the principle of
definition.  Note that:
      (OR (ARRAY-RECOGNIZER (STOREA A I V))
          (EQUAL (STOREA A I V) A))
is a theorem.




[ 0.0 0.0 0.0 ]

(PROVE-LEMMA STORE-IS-PROPER (REWRITE) (EQUAL (arrayp (storea A I V)) T))

     Name the conjecture *1.


     Perhaps we can prove it by induction.  There is only one plausible
induction.  We will induct according to the following scheme:
      (AND (IMPLIES (NOT (ARRAYP A)) (p A I V))
           (IMPLIES (AND (ARRAYP A) (NOT (NUMBERP I)))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (EQUAL A (EMPTY-ARRAY))
                         (EQUAL V (UNDEFINED)))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (EQUAL A (EMPTY-ARRAY))
                         (NOT (EQUAL V (UNDEFINED))))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                         (EQUAL V (UNDEFINED)))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                         (NOT (EQUAL V (UNDEFINED))))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                         (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                         (EQUAL V (UNDEFINED)))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                         (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                         (NOT (EQUAL V (UNDEFINED))))
                    (p A I V))
           (IMPLIES (AND (ARRAYP A)
                         (NUMBERP I)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                         (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                         (p (ARRAY-PREV A) I V))
                    (p A I V))).
Linear arithmetic and the lemma STOREA-IS-SOUND establish that the measure
(COUNT A) decreases according to the well-founded relation LESSP in each
induction step of the scheme.  The above induction scheme produces the
following nine new goals:

Case 9. (IMPLIES (NOT (ARRAYP A))
                 (ARRAYP (STOREA A I V))).

  This simplifies, expanding STOREA and ARRAYP, to:

        T.

Case 8. (IMPLIES (AND (ARRAYP A) (NOT (NUMBERP I)))
                 (ARRAYP (STOREA A I V))).

  This simplifies, unfolding STOREA, to:

        T.

Case 7. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (EQUAL A (EMPTY-ARRAY))
                      (EQUAL V (UNDEFINED)))
                 (ARRAYP (STOREA A I V))).

  This simplifies, opening up ARRAYP, EQUAL, and STOREA, to:

        T.

Case 6. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (EQUAL A (EMPTY-ARRAY))
                      (NOT (EQUAL V (UNDEFINED))))
                 (ARRAYP (STOREA A I V))).

  This simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL,
  ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
  opening up ARRAYP, EQUAL, STOREA, and ARRAY-RECOGNIZER, to:

        T.

Case 5. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                      (EQUAL V (UNDEFINED)))
                 (ARRAYP (STOREA A I V))),

  which simplifies, expanding EQUAL and STOREA, to the formula:

        (IMPLIES (AND (ARRAYP A)
                      (NOT (EQUAL A (EMPTY-ARRAY))))
                 (ARRAYP (ARRAY-PREV A))).

  However this again simplifies, expanding the function ARRAYP, to:

        T.

Case 4. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                      (NOT (EQUAL V (UNDEFINED))))
                 (ARRAYP (STOREA A I V))),

  which simplifies, applying ARRAY-PREV-ARRAY-SHELL,
  ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
  opening up the definitions of STOREA and ARRAYP, to the following two new
  conjectures:

  Case 4.2.
          (IMPLIES (AND (ARRAYP A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL V (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))))
                   (ARRAYP (ARRAY-PREV A))).

    However this again simplifies, expanding ARRAYP, to:

          T.

  Case 4.1.
          (IMPLIES (AND (ARRAYP A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL V (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                          (ARRAY-ELT-SUBSCRIPT A))),

    which again simplifies, expanding the definition of ARRAYP, to:

          T.

Case 3. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                      (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                      (EQUAL V (UNDEFINED)))
                 (ARRAYP (STOREA A I V))),

  which simplifies, opening up the definitions of EQUAL and STOREA, to:

        T.

Case 2. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                      (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                      (NOT (EQUAL V (UNDEFINED))))
                 (ARRAYP (STOREA A I V))),

  which simplifies, expanding the function STOREA, to:

        (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                      (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                      (NOT (EQUAL V (UNDEFINED))))
                 (ARRAYP (ARRAY-SHELL V I A))).

  Appealing to the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
  we now replace A by (ARRAY-SHELL W X Z) to eliminate (ARRAY-ELT-SUBSCRIPT A),
  (ARRAY-PREV A), and (ARRAY-ELT-VALUE A).  We use the type restriction lemma
  noted when ARRAY-ELT-SUBSCRIPT was introduced and the type restriction lemma
  noted when ARRAY-PREV was introduced to constrain the new variables.  This
  generates two new formulas:

  Case 2.2.
          (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                        (ARRAYP A)
                        (NUMBERP I)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (ARRAYP (ARRAY-SHELL V I A))),

    which further simplifies, opening up the function ARRAYP, to:

          T.

  Case 2.1.
          (IMPLIES (AND (NUMBERP X)
                        (ARRAY-RECOGNIZER Z)
                        (ARRAYP (ARRAY-SHELL W X Z))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-SHELL W X Z)
                                    (EMPTY-ARRAY)))
                        (NOT (EQUAL X I))
                        (LESSP X I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (ARRAYP (ARRAY-SHELL V I
                                        (ARRAY-SHELL W X Z)))),

    which further simplifies, applying the lemmas ARRAY-PREV-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
    unfolding ARRAYP, EQUAL, and ARRAY-RECOGNIZER, to:

          T.

Case 1. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                      (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                      (ARRAYP (STOREA (ARRAY-PREV A) I V)))
                 (ARRAYP (STOREA A I V))),

  which simplifies, applying ARRAY-PREV-ARRAY-SHELL,
  ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
  opening up the definitions of ARRAYP, STOREA, and EQUAL, to the following
  two new conjectures:

  Case 1.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (ARRAYP (STOREA (ARRAY-PREV A) I V))
                        (NOT (EQUAL (STOREA (ARRAY-PREV A) I V)
                                    (EMPTY-ARRAY))))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-PREV A) I V))
                          (ARRAY-ELT-SUBSCRIPT A))).

    But this again simplifies, applying the lemma
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding EQUAL, ARRAYP, and STOREA,
    to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (EQUAL V (UNDEFINED)))
                        (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY))))
                   (LESSP I (ARRAY-ELT-SUBSCRIPT A))).

    But this again simplifies, using linear arithmetic, to:

          T.

  Case 1.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (ARRAYP (STOREA (ARRAY-PREV A) I V))
                        (NOT (EQUAL (STOREA (ARRAY-PREV A) I V)
                                    (EMPTY-ARRAY))))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-PREV A) I V))
                          (ARRAY-ELT-SUBSCRIPT A))).

    Applying the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    replace A by (ARRAY-SHELL X W Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A) and Z by (ARRAY-SHELL X1 D C)
    to eliminate (ARRAY-ELT-SUBSCRIPT Z), (ARRAY-PREV Z), and
    (ARRAY-ELT-VALUE Z).  We use the type restriction lemma noted when
    ARRAY-ELT-SUBSCRIPT was introduced and the type restriction lemma noted
    when ARRAY-PREV was introduced to restrict the new variables.  This
    produces the following two new conjectures:

    Case 1.1.2.
            (IMPLIES (AND (EQUAL Z (EMPTY-ARRAY))
                          (ARRAY-RECOGNIZER Z)
                          (NUMBERP W)
                          (NOT (EQUAL X (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT Z) W)
                          (ARRAYP Z)
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-SHELL X W Z)
                                      (EMPTY-ARRAY)))
                          (NOT (EQUAL W I))
                          (NOT (LESSP W I))
                          (ARRAYP (STOREA Z I V))
                          (NOT (EQUAL (STOREA Z I V) (EMPTY-ARRAY))))
                     (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA Z I V))
                            W)).

      However this further simplifies, applying
      ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the definitions of
      ARRAY-RECOGNIZER, ARRAY-ELT-SUBSCRIPT, EQUAL, LESSP, ARRAYP, and STOREA,
      to:

            (IMPLIES (AND (NUMBERP W)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL W 0))
                          (NUMBERP I)
                          (NOT (EQUAL W I))
                          (NOT (LESSP W I))
                          (NOT (EQUAL V (UNDEFINED)))
                          (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY))))
                     (LESSP I W)),

      which again simplifies, using linear arithmetic, to:

            T.

    Case 1.1.1.
            (IMPLIES
                 (AND (NUMBERP D)
                      (ARRAY-RECOGNIZER C)
                      (NOT (EQUAL (ARRAY-SHELL X1 D C)
                                  (EMPTY-ARRAY)))
                      (NUMBERP W)
                      (NOT (EQUAL X (UNDEFINED)))
                      (LESSP D W)
                      (ARRAYP (ARRAY-SHELL X1 D C))
                      (NUMBERP I)
                      (NOT (EQUAL (ARRAY-SHELL X W (ARRAY-SHELL X1 D C))
                                  (EMPTY-ARRAY)))
                      (NOT (EQUAL W I))
                      (NOT (LESSP W I))
                      (ARRAYP (STOREA (ARRAY-SHELL X1 D C) I V))
                      (NOT (EQUAL (STOREA (ARRAY-SHELL X1 D C) I V)
                                  (EMPTY-ARRAY))))
                 (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-SHELL X1 D C) I V))
                        W)),

      which further simplifies, rewriting with the lemmas
      ARRAY-PREV-ARRAY-SHELL, ARRAY-ELT-VALUE-ARRAY-SHELL, and
      ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding the definitions of ARRAYP,
      STOREA, EQUAL, and ARRAY-RECOGNIZER, to five new goals:

      Case 1.1.1.5.
              (IMPLIES (AND (NUMBERP D)
                            (ARRAY-RECOGNIZER C)
                            (NUMBERP W)
                            (NOT (EQUAL X (UNDEFINED)))
                            (LESSP D W)
                            (NOT (EQUAL X1 (UNDEFINED)))
                            (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                            (ARRAYP C)
                            (NUMBERP I)
                            (NOT (EQUAL W I))
                            (NOT (LESSP W I))
                            (EQUAL D I)
                            (ARRAYP (ARRAY-SHELL V D C))
                            (EQUAL V (UNDEFINED))
                            (NOT (EQUAL C (EMPTY-ARRAY))))
                       (LESSP (ARRAY-ELT-SUBSCRIPT C) W)),

        which again simplifies, using linear arithmetic, to:

              T.

      Case 1.1.1.4.
              (IMPLIES (AND (NUMBERP D)
                            (ARRAY-RECOGNIZER C)
                            (NUMBERP W)
                            (NOT (EQUAL X (UNDEFINED)))
                            (LESSP D W)
                            (NOT (EQUAL X1 (UNDEFINED)))
                            (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                            (ARRAYP C)
                            (NUMBERP I)
                            (NOT (EQUAL W I))
                            (NOT (LESSP W I))
                            (LESSP D I)
                            (EQUAL V (UNDEFINED))
                            (ARRAYP (ARRAY-SHELL X1 D C))
                            (EQUAL D I)
                            (NOT (EQUAL C (EMPTY-ARRAY))))
                       (LESSP (ARRAY-ELT-SUBSCRIPT C) W)),

        which again simplifies, using linear arithmetic, to:

              T.

      Case 1.1.1.3.
              (IMPLIES (AND (NUMBERP D)
                            (ARRAY-RECOGNIZER C)
                            (NUMBERP W)
                            (NOT (EQUAL X (UNDEFINED)))
                            (LESSP D W)
                            (NOT (EQUAL X1 (UNDEFINED)))
                            (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                            (ARRAYP C)
                            (NUMBERP I)
                            (NOT (EQUAL W I))
                            (NOT (LESSP W I))
                            (NOT (EQUAL D I))
                            (LESSP D I)
                            (NOT (EQUAL V (UNDEFINED)))
                            (ARRAYP (ARRAY-SHELL V I
                                                 (ARRAY-SHELL X1 D C))))
                       (LESSP I W)),

        which again simplifies, using linear arithmetic, to:

              T.

      Case 1.1.1.2.
              (IMPLIES (AND (NUMBERP D)
                            (ARRAY-RECOGNIZER C)
                            (NUMBERP W)
                            (NOT (EQUAL X (UNDEFINED)))
                            (LESSP D W)
                            (NOT (EQUAL X1 (UNDEFINED)))
                            (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                            (ARRAYP C)
                            (NUMBERP I)
                            (NOT (EQUAL W I))
                            (NOT (LESSP W I))
                            (EQUAL D I)
                            (EQUAL V (UNDEFINED))
                            (NOT (EQUAL C (EMPTY-ARRAY))))
                       (LESSP (ARRAY-ELT-SUBSCRIPT C) W)),

        which again simplifies, using linear arithmetic, to:

              T.

      Case 1.1.1.1.
              (IMPLIES
                  (AND (NUMBERP D)
                       (ARRAY-RECOGNIZER C)
                       (NUMBERP W)
                       (NOT (EQUAL X (UNDEFINED)))
                       (LESSP D W)
                       (NOT (EQUAL X1 (UNDEFINED)))
                       (EQUAL C (EMPTY-ARRAY))
                       (NUMBERP I)
                       (NOT (EQUAL W I))
                       (NOT (LESSP W I))
                       (NOT (EQUAL D I))
                       (LESSP D I)
                       (NOT (EQUAL V (UNDEFINED)))
                       (ARRAYP (ARRAY-SHELL V I
                                            (ARRAY-SHELL X1 D (EMPTY-ARRAY)))))
                  (LESSP I W)),

        which again simplifies, using linear arithmetic, to:

              T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.1 0.0 ]

(PROVE-LEMMA SELECT-OF-STORE-1 (REWRITE) (IMPLIES (AND (arrayp A) (NUMBERP I)) (EQUAL (selecta (storea A I V) I) V)))

     Give the conjecture the name *1.


     Let us appeal to the induction principle.  The recursive terms in the
conjecture suggest two inductions.  However, they merge into one likely
candidate induction.  We will induct according to the following scheme:
      (AND (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (EQUAL A (EMPTY-ARRAY)))
                    (p A I V))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                             (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED))))
                    (p A I V))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                    (p A I V))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                         (p (ARRAY-PREV A) I V))
                    (p A I V))
           (IMPLIES (NOT (ARRAY-RECOGNIZER A))
                    (p A I V))).
Linear arithmetic and the lemma ARRAY-PREV-LESSP can be used to show that the
measure (COUNT A) decreases according to the well-founded relation LESSP in
each induction step of the scheme.  The above induction scheme generates the
following six new conjectures:

Case 6. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (EQUAL A (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)).

  This simplifies, opening up the functions ARRAY-RECOGNIZER, ARRAYP, EQUAL,
  and STOREA, to the following two new goals:

  Case 6.2.
          (IMPLIES (AND (NUMBERP I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   I)
                          V)).

    But this again simplifies, applying ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding SELECTA, to:

          T.

  Case 6.1.
          (IMPLIES (AND (NUMBERP I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (EMPTY-ARRAY) I) V)).

    This again simplifies, unfolding the definitions of EQUAL, ARRAY-PREV,
    ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

Case 5. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                          (EQUAL (ARRAY-ELT-VALUE A)
                                 (UNDEFINED)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)),

  which simplifies, opening up NOT, OR, ARRAYP, and EQUAL, to:

        T.

Case 4. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)),

  which simplifies, unfolding the functions NOT, OR, ARRAYP, EQUAL, and STOREA,
  to five new goals:

  Case 4.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) I)
                          V)),

    which again simplifies, applying ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding the definition of SELECTA,
    to:

          T.

  Case 4.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A I) V)).

    This again simplifies, expanding the definitions of EQUAL and SELECTA, to:

          T.

  Case 4.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   I)
                          V)),

    which again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the functions EQUAL,
    ARRAYP, STOREA, and SELECTA, to the following three new goals:

    Case 4.3.3.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                 (EMPTY-ARRAY)))
                     (EQUAL (UNDEFINED) V)).

      This again simplifies, clearly, to:

            T.

    Case 4.3.2.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (EQUAL V (UNDEFINED)))
                     (EQUAL (UNDEFINED) V)).

      This again simplifies, obviously, to:

            T.

    Case 4.3.1.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (EQUAL V (UNDEFINED)))
                          (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                      (EMPTY-ARRAY))))
                     (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                     I)
                            V)).

      But this again simplifies, applying ARRAY-ELT-VALUE-ARRAY-SHELL and
      ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding SELECTA, to:

            T.

  Case 4.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (EMPTY-ARRAY) I) V)).

    However this again simplifies, unfolding the definitions of EQUAL,
    ARRAY-PREV, ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

  Case 4.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   I)
                          V)),

    which again simplifies, rewriting with ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the definition of SELECTA,
    to:

          T.

Case 3. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (NOT (ARRAYP (ARRAY-PREV A)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)).

  This simplifies, unfolding NOT, OR, and ARRAYP, to:

        T.

Case 2. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                      I)
                             V)
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)).

  This simplifies, unfolding the definitions of NOT, OR, ARRAYP, and STOREA,
  to the following five new formulas:

  Case 2.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) I)
                          V)).

    But this again simplifies, rewriting with ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the definition of SELECTA,
    to:

          T.

  Case 2.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A I) V)).

    But this again simplifies, expanding the definition of SELECTA, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I (UNDEFINED))
                                        I)
                               (UNDEFINED))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                   (EQUAL (SELECTA (ARRAY-PREV A) I)
                          (UNDEFINED))).

    Appealing to the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    we now replace A by (ARRAY-SHELL X W Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A) and Z by (ARRAY-SHELL X1 D C)
    to eliminate (ARRAY-ELT-SUBSCRIPT Z), (ARRAY-PREV Z), and
    (ARRAY-ELT-VALUE Z).  We employ the type restriction lemma noted when
    ARRAY-ELT-SUBSCRIPT was introduced and the type restriction lemma noted
    when ARRAY-PREV was introduced to constrain the new variables.  This
    generates:

          (IMPLIES (AND (NUMBERP D)
                        (ARRAY-RECOGNIZER C)
                        (NUMBERP W)
                        (NOT (EQUAL (ARRAY-SHELL X W (ARRAY-SHELL X1 D C))
                                    (EMPTY-ARRAY)))
                        (NOT (EQUAL X (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-SHELL X1 D C)
                                    (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-SHELL X1 D C)
                                                I
                                                (UNDEFINED))
                                        I)
                               (UNDEFINED))
                        (LESSP D W)
                        (ARRAYP (ARRAY-SHELL X1 D C))
                        (NUMBERP I)
                        (NOT (EQUAL W I))
                        (LESSP W I))
                   (EQUAL (SELECTA (ARRAY-SHELL X1 D C) I)
                          (UNDEFINED))).

    But this further simplifies, rewriting with
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, ARRAY-ELT-VALUE-ARRAY-SHELL, and
    ARRAY-PREV-ARRAY-SHELL, and expanding the definitions of EQUAL, ARRAYP,
    STOREA, ARRAY-RECOGNIZER, and SELECTA, to the following three new goals:

    Case 2.4.3.
            (IMPLIES (AND (NUMBERP D)
                          (ARRAY-RECOGNIZER C)
                          (NUMBERP W)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL X1 (UNDEFINED)))
                          (EQUAL C (EMPTY-ARRAY))
                          (EQUAL D I)
                          (EQUAL (SELECTA C I) (UNDEFINED))
                          (LESSP D W)
                          (NOT (EQUAL W D)))
                     (NOT (LESSP W D))).

      But this again simplifies, using linear arithmetic, to:

            T.

    Case 2.4.2.
            (IMPLIES (AND (NUMBERP D)
                          (ARRAY-RECOGNIZER C)
                          (NUMBERP W)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL X1 (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                          (ARRAYP C)
                          (EQUAL D I)
                          (EQUAL (SELECTA C I) (UNDEFINED))
                          (LESSP D W)
                          (NOT (EQUAL W D)))
                     (NOT (LESSP W D))),

      which again simplifies, using linear arithmetic, to:

            T.

    Case 2.4.1.
            (IMPLIES
                    (AND (NUMBERP D)
                         (ARRAY-RECOGNIZER C)
                         (NUMBERP W)
                         (NOT (EQUAL X (UNDEFINED)))
                         (NOT (EQUAL X1 (UNDEFINED)))
                         (LESSP (ARRAY-ELT-SUBSCRIPT C) D)
                         (ARRAYP C)
                         (NOT (EQUAL D I))
                         (NOT (LESSP D I))
                         (EQUAL (SELECTA (ARRAY-SHELL X1 D
                                                      (STOREA C I (UNDEFINED)))
                                         I)
                                (UNDEFINED))
                         (LESSP D W)
                         (NUMBERP I)
                         (NOT (EQUAL W I))
                         (LESSP W I)
                         (NOT (EQUAL C (EMPTY-ARRAY))))
                    (EQUAL (SELECTA C I) (UNDEFINED))),

      which again simplifies, using linear arithmetic, to:

            T.

  Case 2.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   I)
                          V)),

    which again simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the function SELECTA, to
    the new conjecture:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (EQUAL (STOREA (ARRAY-PREV A) I V)
                               (EMPTY-ARRAY)))
                   (EQUAL (UNDEFINED) V)),

    which again simplifies, unfolding EQUAL, ARRAY-PREV, ARRAY-ELT-VALUE,
    ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

  Case 2.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (ARRAY-PREV A) I) V)),

    which again simplifies, applying X-NOT-LESS-THAN-X, and opening up EQUAL
    and STOREA, to:

          T.

  Case 2.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        I)
                               V)
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (ARRAY-PREV A))
                                   I)
                          V)).

    This again simplifies, rewriting with X-NOT-LESS-THAN-X, and expanding the
    function STOREA, to:

          T.

Case 1. (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (SELECTA (STOREA A I V) I) V)).

  This simplifies, opening up ARRAYP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA SELECT-OF-STORE-2 (REWRITE) (IMPLIES (AND (arrayp A) (NUMBERP I) (NUMBERP J) (NOT (EQUAL I J))) (EQUAL (selecta (storea A I V) J) (selecta A J))))

     Name the conjecture *1.


     Let us appeal to the induction principle.  The recursive terms in the
conjecture suggest three inductions.  However, they merge into one likely
candidate induction.  We will induct according to the following scheme:
      (AND (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (EQUAL A (EMPTY-ARRAY)))
                    (p A I V J))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                             (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED))))
                    (p A I V J))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                    (p A I V J))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                         (p (ARRAY-PREV A) I V J))
                    (p A I V J))
           (IMPLIES (NOT (ARRAY-RECOGNIZER A))
                    (p A I V J))).
Linear arithmetic and the lemma ARRAY-PREV-LESSP can be used to prove that the
measure (COUNT A) decreases according to the well-founded relation LESSP in
each induction step of the scheme.  The above induction scheme leads to the
following six new goals:

Case 6. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (EQUAL A (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))).

  This simplifies, expanding the functions ARRAY-RECOGNIZER, ARRAYP, EQUAL,
  STOREA, ARRAY-PREV, ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to
  the following two new formulas:

  Case 6.2.
          (IMPLIES (AND (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   J)
                          (UNDEFINED))).

    However this again simplifies, applying the lemmas ARRAY-PREV-ARRAY-SHELL
    and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the functions EQUAL,
    ARRAY-RECOGNIZER, and SELECTA, to:

          T.

  Case 6.1.
          (IMPLIES (AND (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (EMPTY-ARRAY) J)
                          (UNDEFINED))),

    which again simplifies, unfolding the definitions of EQUAL, ARRAY-PREV,
    ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

Case 5. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                          (EQUAL (ARRAY-ELT-VALUE A)
                                 (UNDEFINED)))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))),

  which simplifies, expanding the functions NOT, OR, ARRAYP, and EQUAL, to:

        T.

Case 4. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))),

  which simplifies, expanding the functions NOT, OR, ARRAYP, EQUAL, STOREA,
  and SELECTA, to ten new conjectures:

  Case 4.10.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) J)
                          (UNDEFINED))),

    which again simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the definitions of EQUAL
    and SELECTA, to:

          T.

  Case 4.9.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A J) (UNDEFINED))).

    However this again simplifies, unfolding the functions SELECTA and EQUAL,
    to:

          T.

  Case 4.8.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   J)
                          (UNDEFINED))),

    which again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the functions EQUAL,
    ARRAYP, STOREA, and SELECTA, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (EQUAL V (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                    (EMPTY-ARRAY))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   J)
                          (UNDEFINED))),

    which again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding EQUAL, ARRAY-RECOGNIZER,
    and SELECTA, to:

          T.

  Case 4.7.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (EMPTY-ARRAY) J)
                          (UNDEFINED))).

    This again simplifies, unfolding the functions EQUAL, ARRAY-PREV,
    ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

  Case 4.6.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   J)
                          (UNDEFINED))),

    which again simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding the functions EQUAL,
    ARRAY-RECOGNIZER, and SELECTA, to:

          T.

  Case 4.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the function SELECTA, to:

          T.

  Case 4.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, expanding the definition of SELECTA, to:

          T.

  Case 4.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   J)
                          (ARRAY-ELT-VALUE A))),

    which again simplifies, applying ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and expanding the definitions of EQUAL,
    ARRAYP, STOREA, and SELECTA, to:

          T.

  Case 4.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (EMPTY-ARRAY) J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, obviously, to:

          T.

  Case 4.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                   J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, obviously, to:

          T.

Case 3. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (NOT (ARRAYP (ARRAY-PREV A)))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))).

  This simplifies, opening up the functions NOT, OR, and ARRAYP, to:

        T.

Case 2. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                      J)
                             (SELECTA (ARRAY-PREV A) J))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))).

  This simplifies, opening up NOT, OR, ARRAYP, STOREA, and SELECTA, to the
  following nine new goals:

  Case 2.9.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) J)
                          (SELECTA (ARRAY-PREV A) J))).

    But this again simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and unfolding the definition of SELECTA,
    to:

          T.

  Case 2.8.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A J)
                          (SELECTA (ARRAY-PREV A) J))).

    But this again simplifies, unfolding SELECTA, to:

          T.

  Case 2.7.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   J)
                          (SELECTA (ARRAY-PREV A) J))),

    which again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the definition of SELECTA,
    to the new conjecture:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (EQUAL (STOREA (ARRAY-PREV A) I V)
                               (EMPTY-ARRAY)))
                   (EQUAL (UNDEFINED)
                          (SELECTA (ARRAY-PREV A) J))),

    which again simplifies, opening up the functions EQUAL, ARRAY-PREV,
    ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, and SELECTA, to:

          T.

  Case 2.6.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (ARRAY-PREV A))
                                   J)
                          (SELECTA (ARRAY-PREV A) J))),

    which again simplifies, applying X-NOT-LESS-THAN-X, and expanding the
    definition of STOREA, to:

          T.

  Case 2.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I A) J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, applying ARRAY-PREV-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up SELECTA, to:

          T.

  Case 2.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA A J)
                          (ARRAY-ELT-VALUE A))).

    But this again simplifies, opening up the function SELECTA, to:

          T.

  Case 2.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (SELECTA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                                (ARRAY-ELT-SUBSCRIPT A)
                                                (STOREA (ARRAY-PREV A) I V))
                                   J)
                          (ARRAY-ELT-VALUE A))),

    which again simplifies, rewriting with ARRAY-ELT-VALUE-ARRAY-SHELL and
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and opening up the function SELECTA, to:

          T.

  Case 2.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (SELECTA (ARRAY-PREV A) J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, clearly, to:

          T.

  Case 2.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (SELECTA (STOREA (ARRAY-PREV A) I V)
                                        J)
                               (SELECTA (ARRAY-PREV A) J))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NUMBERP J)
                        (NOT (EQUAL I J))
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) J)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (SELECTA (ARRAY-SHELL V I (ARRAY-PREV A))
                                   J)
                          (ARRAY-ELT-VALUE A))).

    This again simplifies, obviously, to:

          T.

Case 1. (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                      (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))).

  This simplifies, expanding the function ARRAYP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.1 0.0 ]

(PROVE-LEMMA SELECT-OF-STORE (REWRITE) (IMPLIES (AND (arrayp A) (NUMBERP I) (NUMBERP J)) (EQUAL (selecta (storea A I V) J) (IF (EQUAL I J) V (selecta A J)))))
WARNING:  the newly proposed lemma, SELECT-OF-STORE, could be applied whenever
the previously added lemma SELECT-OF-STORE-2 could.




WARNING:  the newly proposed lemma, SELECT-OF-STORE, could be applied whenever
the previously added lemma SELECT-OF-STORE-1 could.




This simplifies, obviously, to two new goals:

Case 2. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NOT (EQUAL I J)))
                 (EQUAL (SELECTA (STOREA A I V) J)
                        (SELECTA A J))),

  which again simplifies, rewriting with the lemma SELECT-OF-STORE-2, to:

        T.

Case 1. (IMPLIES (AND (ARRAYP A)
                      (NUMBERP I)
                      (NUMBERP J)
                      (EQUAL I J))
                 (EQUAL (SELECTA (STOREA A I V) J) V)),

  which again simplifies, appealing to the lemma SELECT-OF-STORE-1, to:

        T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA STORE-OF-SELECT (REWRITE) (IMPLIES (AND (arrayp A) (NUMBERP I)) (EQUAL (storea A I (selecta A I)) A)))

     Give the conjecture the name *1.


     Let us appeal to the induction principle.  The recursive terms in the
conjecture suggest three inductions.  However, they merge into one likely
candidate induction.  We will induct according to the following scheme:
      (AND (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (EQUAL A (EMPTY-ARRAY)))
                    (p A I))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                             (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED))))
                    (p A I))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                    (p A I))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                         (p (ARRAY-PREV A) I))
                    (p A I))
           (IMPLIES (NOT (ARRAY-RECOGNIZER A))
                    (p A I))).
Linear arithmetic and the lemma ARRAY-PREV-LESSP can be used to show that the
measure (COUNT A) decreases according to the well-founded relation LESSP in
each induction step of the scheme.  The above induction scheme generates the
following six new conjectures:

Case 6. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (EQUAL A (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, opening up the functions ARRAY-RECOGNIZER, ARRAYP, EQUAL,
  ARRAY-PREV, ARRAY-ELT-VALUE, ARRAY-ELT-SUBSCRIPT, SELECTA, and STOREA, to:

        T.

Case 5. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                          (EQUAL (ARRAY-ELT-VALUE A)
                                 (UNDEFINED)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, unfolding the functions NOT, OR, ARRAYP, and EQUAL, to:

        T.

Case 4. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, expanding NOT, OR, ARRAYP, EQUAL, and SELECTA, to the
  following two new conjectures:

  Case 4.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (STOREA A I (UNDEFINED)) A)).

    However this again simplifies, opening up the functions EQUAL, ARRAYP, and
    STOREA, to the goal:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                       (ARRAY-ELT-SUBSCRIPT A)
                                       (EMPTY-ARRAY))
                          A)).

    Appealing to the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    we now replace A by (ARRAY-SHELL X V Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A).  We use the type restriction
    lemma noted when ARRAY-PREV was introduced and the type restriction lemma
    noted when ARRAY-ELT-SUBSCRIPT was introduced to constrain the new
    variables.  This generates:

          (IMPLIES (AND (ARRAY-RECOGNIZER Z)
                        (NUMBERP V)
                        (NOT (EQUAL (ARRAY-SHELL X V Z)
                                    (EMPTY-ARRAY)))
                        (NOT (EQUAL X (UNDEFINED)))
                        (EQUAL Z (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL V I))
                        (NOT (LESSP V I)))
                   (EQUAL (ARRAY-SHELL X V (EMPTY-ARRAY))
                          (ARRAY-SHELL X V Z))).

    This further simplifies, clearly, to:

          T.

  Case 4.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                   (EQUAL (STOREA A I (ARRAY-ELT-VALUE A))
                          A)).

    This again simplifies, expanding the definitions of EQUAL, ARRAYP, and
    STOREA, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                   (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                       (ARRAY-ELT-SUBSCRIPT A)
                                       (EMPTY-ARRAY))
                          A)).

    Appealing to the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    we now replace A by (ARRAY-SHELL X V Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A).  We use the type restriction
    lemma noted when ARRAY-PREV was introduced and the type restriction lemma
    noted when ARRAY-ELT-SUBSCRIPT was introduced to constrain the new
    variables.  This generates the goal:

          (IMPLIES (AND (ARRAY-RECOGNIZER Z)
                        (NUMBERP V)
                        (NOT (EQUAL (ARRAY-SHELL X V Z)
                                    (EMPTY-ARRAY)))
                        (NOT (EQUAL X (UNDEFINED)))
                        (EQUAL Z (EMPTY-ARRAY)))
                   (EQUAL (ARRAY-SHELL X V (EMPTY-ARRAY))
                          (ARRAY-SHELL X V Z))).

    This further simplifies, trivially, to:

          T.

Case 3. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (NOT (ARRAYP (ARRAY-PREV A)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, opening up the functions NOT, OR, and ARRAYP, to:

        T.

Case 2. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (EQUAL (STOREA (ARRAY-PREV A)
                                     I
                                     (SELECTA (ARRAY-PREV A) I))
                             (ARRAY-PREV A))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, expanding NOT, OR, ARRAYP, and SELECTA, to the following
  two new formulas:

  Case 2.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (ARRAY-PREV A)
                                       I
                                       (SELECTA (ARRAY-PREV A) I))
                               (ARRAY-PREV A))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (STOREA A I
                                  (SELECTA (ARRAY-PREV A) I))
                          A)).

    However this again simplifies, rewriting with
    ARRAY-SHELL-ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV, and opening up
    ARRAYP and STOREA, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (ARRAY-PREV A)
                                       I
                                       (SELECTA (ARRAY-PREV A) I))
                               (ARRAY-PREV A))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL (SELECTA (ARRAY-PREV A) I)
                                    (UNDEFINED))))
                   (EQUAL (ARRAY-SHELL (SELECTA (ARRAY-PREV A) I)
                                       I A)
                          A)),

    which again simplifies, trivially, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (ARRAY-PREV A)
                                       I
                                       (SELECTA (ARRAY-PREV A) I))
                               (ARRAY-PREV A))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                   (EQUAL (SELECTA (ARRAY-PREV A) I)
                          (UNDEFINED))).

    Applying the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    replace A by (ARRAY-SHELL X V Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A) and Z by (ARRAY-SHELL C W D)
    to eliminate (ARRAY-ELT-SUBSCRIPT Z), (ARRAY-PREV Z), and
    (ARRAY-ELT-VALUE Z).  We rely upon the type restriction lemma noted when
    ARRAY-ELT-SUBSCRIPT was introduced and the type restriction lemma noted
    when ARRAY-PREV was introduced to restrict the new variables.  We would
    thus like to prove:

          (IMPLIES (AND (NUMBERP W)
                        (ARRAY-RECOGNIZER D)
                        (NUMBERP V)
                        (NOT (EQUAL (ARRAY-SHELL X V (ARRAY-SHELL C W D))
                                    (EMPTY-ARRAY)))
                        (NOT (EQUAL X (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-SHELL C W D)
                                    (EMPTY-ARRAY)))
                        (EQUAL (STOREA (ARRAY-SHELL C W D)
                                       I
                                       (SELECTA (ARRAY-SHELL C W D) I))
                               (ARRAY-SHELL C W D))
                        (LESSP W V)
                        (ARRAYP (ARRAY-SHELL C W D))
                        (NUMBERP I)
                        (NOT (EQUAL V I))
                        (LESSP V I))
                   (EQUAL (SELECTA (ARRAY-SHELL C W D) I)
                          (UNDEFINED))),

    which further simplifies, appealing to the lemmas ARRAY-PREV-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
    unfolding SELECTA, ARRAYP, STOREA, EQUAL, ARRAY-RECOGNIZER, ARRAY-PREV,
    ARRAY-ELT-VALUE, and ARRAY-ELT-SUBSCRIPT, to five new formulas:

    Case 2.2.5.
            (IMPLIES (AND (NUMBERP W)
                          (ARRAY-RECOGNIZER D)
                          (NUMBERP V)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL C (UNDEFINED)))
                          (EQUAL D (EMPTY-ARRAY))
                          (EQUAL W I)
                          (EQUAL (ARRAY-SHELL C I D)
                                 (ARRAY-SHELL C W D))
                          (LESSP I V)
                          (NOT (EQUAL V I)))
                     (NOT (LESSP V I))),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.2.4.
            (IMPLIES (AND (NUMBERP W)
                          (ARRAY-RECOGNIZER D)
                          (NUMBERP V)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL C (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT D) W)
                          (ARRAYP D)
                          (EQUAL W I)
                          (EQUAL (ARRAY-SHELL C I D)
                                 (ARRAY-SHELL C W D))
                          (LESSP I V)
                          (EQUAL D (EMPTY-ARRAY))
                          (NOT (EQUAL V I)))
                     (NOT (LESSP V I))),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.2.3.
            (IMPLIES (AND (NUMBERP W)
                          (ARRAY-RECOGNIZER D)
                          (NUMBERP V)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL C (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT D) W)
                          (ARRAYP D)
                          (EQUAL W I)
                          (EQUAL (ARRAY-SHELL C I D)
                                 (ARRAY-SHELL C W D))
                          (LESSP I V)
                          (LESSP (ARRAY-ELT-SUBSCRIPT D) I)
                          (NOT (EQUAL V I)))
                     (NOT (LESSP V I))),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.2.2.
            (IMPLIES (AND (NUMBERP W)
                          (ARRAY-RECOGNIZER D)
                          (NUMBERP V)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL C (UNDEFINED)))
                          (NOT (EQUAL D (EMPTY-ARRAY)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT D) W)
                          (ARRAYP D)
                          (NOT (EQUAL W I))
                          (NOT (LESSP W I))
                          (EQUAL (ARRAY-SHELL C W
                                              (STOREA D I (SELECTA D I)))
                                 (ARRAY-SHELL C W D))
                          (LESSP W V)
                          (NUMBERP I)
                          (NOT (EQUAL V I))
                          (LESSP V I))
                     (EQUAL (SELECTA D I) (UNDEFINED))),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.2.1.
            (IMPLIES (AND (NUMBERP W)
                          (ARRAY-RECOGNIZER D)
                          (NUMBERP V)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL C (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT D) W)
                          (ARRAYP D)
                          (NOT (EQUAL W I))
                          (LESSP W I)
                          (EQUAL (ARRAY-SHELL (SELECTA D I)
                                              I
                                              (ARRAY-SHELL C W D))
                                 (ARRAY-SHELL C W D))
                          (LESSP W V)
                          (NUMBERP I)
                          (NOT (EQUAL V I))
                          (LESSP V I)
                          (NOT (EQUAL D (EMPTY-ARRAY))))
                     (EQUAL (SELECTA D I) (UNDEFINED))),

      which finally simplifies, rewriting with ARRAY-SHELL-EQUAL, to:

            T.

  Case 2.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (ARRAY-PREV A)
                                       I
                                       (SELECTA (ARRAY-PREV A) I))
                               (ARRAY-PREV A))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                   (EQUAL (STOREA A I (ARRAY-ELT-VALUE A))
                          A)).

    But this again simplifies, rewriting with X-NOT-LESS-THAN-X and
    ARRAY-SHELL-ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV, and expanding
    the definitions of STOREA and ARRAYP, to:

          T.

Case 1. (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA A I (SELECTA A I)) A)).

  This simplifies, expanding the function ARRAYP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA STORE-OF-STORE-1 (REWRITE) (IMPLIES (AND (arrayp A) (NUMBERP I)) (EQUAL (storea (storea A I V) I W) (storea A I W))))

     Give the conjecture the name *1.


     We will appeal to induction.  Three inductions are suggested by terms in
the conjecture.  However, they merge into one likely candidate induction.  We
will induct according to the following scheme:
      (AND (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (EQUAL A (EMPTY-ARRAY)))
                    (p A I V W))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                             (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED))))
                    (p A I V W))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                    (p A I V W))
           (IMPLIES (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                                  (EQUAL (ARRAY-ELT-VALUE A)
                                         (UNDEFINED))))
                         (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                         (p (ARRAY-PREV A) I V W))
                    (p A I V W))
           (IMPLIES (NOT (ARRAY-RECOGNIZER A))
                    (p A I V W))).
Linear arithmetic and the lemma ARRAY-PREV-LESSP can be used to establish that
the measure (COUNT A) decreases according to the well-founded relation LESSP
in each induction step of the scheme.  The above induction scheme leads to six
new goals:

Case 6. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (EQUAL A (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))),

  which simplifies, unfolding the functions ARRAY-RECOGNIZER, ARRAYP, EQUAL,
  and STOREA, to four new formulas:

  Case 6.4.
          (IMPLIES (AND (NUMBERP I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                  I W)
                          (ARRAY-SHELL W I (EMPTY-ARRAY)))),

    which again simplifies, rewriting with the lemmas
    ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, ARRAY-ELT-VALUE-ARRAY-SHELL, and
    ARRAY-PREV-ARRAY-SHELL, and expanding ARRAYP, ARRAY-RECOGNIZER, EQUAL, and
    STOREA, to:

          T.

  Case 6.3.
          (IMPLIES (AND (NUMBERP I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (EMPTY-ARRAY) I W)
                          (ARRAY-SHELL W I (EMPTY-ARRAY)))),

    which again simplifies, expanding EQUAL, ARRAYP, and STOREA, to:

          T.

  Case 6.2.
          (IMPLIES (AND (NUMBERP I)
                        (EQUAL W (UNDEFINED))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                  I W)
                          (EMPTY-ARRAY))),

    which again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and unfolding the
    functions ARRAYP, ARRAY-RECOGNIZER, EQUAL, and STOREA, to:

          T.

  Case 6.1.
          (IMPLIES (AND (NUMBERP I)
                        (EQUAL W (UNDEFINED))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (EMPTY-ARRAY) I W)
                          (EMPTY-ARRAY))).

    This again simplifies, expanding the functions EQUAL, ARRAYP, and STOREA,
    to:

          T.

Case 5. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                          (EQUAL (ARRAY-ELT-VALUE A)
                                 (UNDEFINED)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))),

  which simplifies, opening up the definitions of NOT, OR, ARRAYP, and EQUAL,
  to:

        T.

Case 4. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))),

  which simplifies, opening up the definitions of NOT, OR, ARRAYP, EQUAL, and
  STOREA, to nine new conjectures:

  Case 4.9.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I A) I W)
                          (ARRAY-SHELL W I A))),

    which again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and unfolding
    ARRAYP, EQUAL, and STOREA, to:

          T.

  Case 4.8.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA A I W)
                          (ARRAY-SHELL W I A))).

    This again simplifies, opening up STOREA, ARRAYP, and EQUAL, to:

          T.

  Case 4.7.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I A) I W)
                          A)),

    which again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and unfolding the
    functions ARRAYP, EQUAL, and STOREA, to:

          T.

  Case 4.6.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA A I W) A)).

    But this again simplifies, unfolding the definitions of EQUAL, ARRAYP, and
    STOREA, to:

          T.

  Case 4.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (STOREA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                               (ARRAY-ELT-SUBSCRIPT A)
                                               (STOREA (ARRAY-PREV A) I V))
                                  I W)
                          (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                       (ARRAY-ELT-SUBSCRIPT A)
                                       (STOREA (ARRAY-PREV A) I W)))),

    which again simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and opening up
    the definitions of EQUAL, ARRAYP, and STOREA, to the following ten new
    conjectures:

    Case 4.5.10.
            (IMPLIES
              (AND (ARRAY-RECOGNIZER A)
                   (NOT (EQUAL A (EMPTY-ARRAY)))
                   (NOT (EQUAL (ARRAY-ELT-VALUE A)
                               (UNDEFINED)))
                   (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                   (NUMBERP I)
                   (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                   (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                   (NOT (EQUAL W (UNDEFINED)))
                   (NOT (EQUAL V (UNDEFINED)))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-SHELL V I (EMPTY-ARRAY)))
                          (ARRAY-ELT-SUBSCRIPT A))
                   (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY))))
              (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                  (ARRAY-ELT-SUBSCRIPT A)
                                  (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                          I W))
                     (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                  (ARRAY-ELT-SUBSCRIPT A)
                                  (ARRAY-SHELL W I (EMPTY-ARRAY))))).

      This again simplifies, rewriting with the lemmas
      ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, ARRAY-PREV-ARRAY-SHELL, and
      ARRAY-ELT-VALUE-ARRAY-SHELL, and expanding EQUAL, ARRAY-RECOGNIZER,
      ARRAYP, and STOREA, to:

            T.

    Case 4.5.9.
            (IMPLIES
                    (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                     (UNDEFINED)))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                         (NUMBERP I)
                         (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                         (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                         (NOT (EQUAL W (UNDEFINED)))
                         (NOT (EQUAL V (UNDEFINED)))
                         (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                (EMPTY-ARRAY)))
                    (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                        (ARRAY-ELT-SUBSCRIPT A)
                                        (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                                I W))
                           (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                        (ARRAY-ELT-SUBSCRIPT A)
                                        (ARRAY-SHELL W I (EMPTY-ARRAY))))),

      which again simplifies, clearly, to:

            T.

    Case 4.5.8.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (EQUAL W (UNDEFINED)))
                          (NOT (EQUAL V (UNDEFINED)))
                          (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                      (EMPTY-ARRAY)))
                          (NOT (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY)))))
                     (EQUAL (EMPTY-ARRAY)
                            (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (ARRAY-SHELL W I (EMPTY-ARRAY))))).

      This again simplifies, rewriting with ARRAY-PREV-ARRAY-SHELL,
      ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
      unfolding the definitions of EQUAL, ARRAY-RECOGNIZER, and ARRAYP, to:

            T.

    Case 4.5.7.
            (IMPLIES
             (AND
              (ARRAY-RECOGNIZER A)
              (NOT (EQUAL A (EMPTY-ARRAY)))
              (NOT (EQUAL (ARRAY-ELT-VALUE A)
                          (UNDEFINED)))
              (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
              (NUMBERP I)
              (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
              (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
              (NOT (EQUAL W (UNDEFINED)))
              (NOT (EQUAL V (UNDEFINED)))
              (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                          (EMPTY-ARRAY)))
              (NOT (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-SHELL V I (EMPTY-ARRAY)))
                          (ARRAY-ELT-SUBSCRIPT A))))
             (EQUAL (EMPTY-ARRAY)
                    (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                 (ARRAY-ELT-SUBSCRIPT A)
                                 (ARRAY-SHELL W I (EMPTY-ARRAY))))).

      However this again simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
      to:

            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (EQUAL W (UNDEFINED)))
                          (NOT (EQUAL V (UNDEFINED))))
                     (LESSP I (ARRAY-ELT-SUBSCRIPT A))),

      which again simplifies, using linear arithmetic, to:

            T.

    Case 4.5.6.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (EQUAL W (UNDEFINED)))
                          (EQUAL V (UNDEFINED)))
                     (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (STOREA (EMPTY-ARRAY) I W))
                            (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (ARRAY-SHELL W I (EMPTY-ARRAY))))),

      which again simplifies, unfolding the definitions of EQUAL, ARRAYP, and
      STOREA, to:

            T.

    Case 4.5.5.
            (IMPLIES
              (AND (ARRAY-RECOGNIZER A)
                   (NOT (EQUAL A (EMPTY-ARRAY)))
                   (NOT (EQUAL (ARRAY-ELT-VALUE A)
                               (UNDEFINED)))
                   (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                   (NUMBERP I)
                   (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                   (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                   (EQUAL W (UNDEFINED))
                   (NOT (EQUAL V (UNDEFINED)))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-SHELL V I (EMPTY-ARRAY)))
                          (ARRAY-ELT-SUBSCRIPT A))
                   (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY))))
              (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                  (ARRAY-ELT-SUBSCRIPT A)
                                  (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                          I W))
                     (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                  (ARRAY-ELT-SUBSCRIPT A)
                                  (EMPTY-ARRAY)))),

      which again simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
      ARRAY-PREV-ARRAY-SHELL, and ARRAY-ELT-VALUE-ARRAY-SHELL, and unfolding
      the functions EQUAL, ARRAY-RECOGNIZER, ARRAYP, and STOREA, to:

            T.

    Case 4.5.4.
            (IMPLIES
                    (AND (ARRAY-RECOGNIZER A)
                         (NOT (EQUAL A (EMPTY-ARRAY)))
                         (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                     (UNDEFINED)))
                         (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                         (NUMBERP I)
                         (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                         (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                         (EQUAL W (UNDEFINED))
                         (NOT (EQUAL V (UNDEFINED)))
                         (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                (EMPTY-ARRAY)))
                    (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                        (ARRAY-ELT-SUBSCRIPT A)
                                        (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                                I W))
                           (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                        (ARRAY-ELT-SUBSCRIPT A)
                                        (EMPTY-ARRAY)))).

      This again simplifies, obviously, to:

            T.

    Case 4.5.3.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (EQUAL W (UNDEFINED))
                          (NOT (EQUAL V (UNDEFINED)))
                          (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                                      (EMPTY-ARRAY)))
                          (NOT (ARRAYP (ARRAY-SHELL V I (EMPTY-ARRAY)))))
                     (EQUAL (EMPTY-ARRAY)
                            (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (EMPTY-ARRAY)))).

      But this again simplifies, applying ARRAY-PREV-ARRAY-SHELL,
      ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL, and
      expanding the functions EQUAL, ARRAY-RECOGNIZER, and ARRAYP, to:

            T.

    Case 4.5.2.
            (IMPLIES
             (AND
              (ARRAY-RECOGNIZER A)
              (NOT (EQUAL A (EMPTY-ARRAY)))
              (NOT (EQUAL (ARRAY-ELT-VALUE A)
                          (UNDEFINED)))
              (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
              (NUMBERP I)
              (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
              (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
              (EQUAL W (UNDEFINED))
              (NOT (EQUAL V (UNDEFINED)))
              (NOT (EQUAL (ARRAY-SHELL V I (EMPTY-ARRAY))
                          (EMPTY-ARRAY)))
              (NOT (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-SHELL V I (EMPTY-ARRAY)))
                          (ARRAY-ELT-SUBSCRIPT A))))
             (EQUAL (EMPTY-ARRAY)
                    (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                 (ARRAY-ELT-SUBSCRIPT A)
                                 (EMPTY-ARRAY)))).

      This again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
      to the new conjecture:

            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (EQUAL V (UNDEFINED))))
                     (LESSP I (ARRAY-ELT-SUBSCRIPT A))),

      which again simplifies, using linear arithmetic, to:

            T.

    Case 4.5.1.
            (IMPLIES (AND (ARRAY-RECOGNIZER A)
                          (NOT (EQUAL A (EMPTY-ARRAY)))
                          (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED)))
                          (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                          (NUMBERP I)
                          (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                          (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                          (EQUAL W (UNDEFINED))
                          (EQUAL V (UNDEFINED)))
                     (EQUAL (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (STOREA (EMPTY-ARRAY) I W))
                            (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                         (ARRAY-ELT-SUBSCRIPT A)
                                         (EMPTY-ARRAY)))),

      which again simplifies, opening up the definitions of EQUAL, ARRAYP, and
      STOREA, to:

            T.

  Case 4.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (EMPTY-ARRAY) I W)
                          (EMPTY-ARRAY))),

    which again simplifies, unfolding the definitions of EQUAL, ARRAYP, and
    STOREA, to:

          T.

  Case 4.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                  I W)
                          (EMPTY-ARRAY))),

    which again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and expanding the
    definitions of ARRAYP, ARRAY-RECOGNIZER, EQUAL, and STOREA, to:

          T.

  Case 4.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (EMPTY-ARRAY) I W)
                          (ARRAY-SHELL W I (EMPTY-ARRAY)))).

    This again simplifies, expanding the definitions of EQUAL, ARRAYP, and
    STOREA, to:

          T.

  Case 4.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (EMPTY-ARRAY))
                                  I W)
                          (ARRAY-SHELL W I (EMPTY-ARRAY)))),

    which again simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and expanding
    ARRAYP, ARRAY-RECOGNIZER, EQUAL, and STOREA, to:

          T.

Case 3. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (NOT (ARRAYP (ARRAY-PREV A)))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))).

  This simplifies, opening up the definitions of NOT, OR, and ARRAYP, to:

        T.

Case 2. (IMPLIES (AND (ARRAY-RECOGNIZER A)
                      (NOT (EQUAL A (EMPTY-ARRAY)))
                      (NOT (OR (NOT (NUMBERP (ARRAY-ELT-SUBSCRIPT A)))
                               (EQUAL (ARRAY-ELT-VALUE A)
                                      (UNDEFINED))))
                      (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                      (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                     I W)
                             (STOREA (ARRAY-PREV A) I W))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))).

  This simplifies, expanding the definitions of NOT, OR, ARRAYP, and STOREA,
  to the following nine new formulas:

  Case 2.9.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I A) I W)
                          (ARRAY-SHELL W I A))).

    But this again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and unfolding the
    functions ARRAYP and STOREA, to:

          T.

  Case 2.8.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA A I W)
                          (ARRAY-SHELL W I A))).

    However this again simplifies, opening up the functions STOREA and ARRAYP,
    to:

          T.

  Case 2.7.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I A) I W)
                          A)),

    which again simplifies, rewriting with ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and expanding the
    functions EQUAL, ARRAYP, and STOREA, to:

          T.

  Case 2.6.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (LESSP (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA A I W) A)).

    But this again simplifies, opening up the definitions of EQUAL, ARRAYP,
    and STOREA, to:

          T.

  Case 2.5.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I)))
                   (EQUAL (STOREA (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                               (ARRAY-ELT-SUBSCRIPT A)
                                               (STOREA (ARRAY-PREV A) I V))
                                  I W)
                          (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                       (ARRAY-ELT-SUBSCRIPT A)
                                       (STOREA (ARRAY-PREV A) I W)))),

    which again simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, ARRAY-PREV-ARRAY-SHELL, and STORE-IS-PROPER,
    and unfolding the functions ARRAYP and STOREA, to the new formula:

          (IMPLIES
             (AND (ARRAY-RECOGNIZER A)
                  (NOT (EQUAL A (EMPTY-ARRAY)))
                  (NOT (EQUAL (ARRAY-ELT-VALUE A)
                              (UNDEFINED)))
                  (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                  (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                 I W)
                         (STOREA (ARRAY-PREV A) I W))
                  (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                         (ARRAY-ELT-SUBSCRIPT A))
                  (ARRAYP (ARRAY-PREV A))
                  (NUMBERP I)
                  (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                  (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                  (NOT (EQUAL (STOREA (ARRAY-PREV A) I V)
                              (EMPTY-ARRAY)))
                  (NOT (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-PREV A) I V))
                              (ARRAY-ELT-SUBSCRIPT A))))
             (EQUAL (EMPTY-ARRAY)
                    (ARRAY-SHELL (ARRAY-ELT-VALUE A)
                                 (ARRAY-ELT-SUBSCRIPT A)
                                 (STOREA (ARRAY-PREV A) I W)))),

    which again simplifies, trivially, to:

          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (NOT (EQUAL (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (LESSP (ARRAY-ELT-SUBSCRIPT A) I))
                        (NOT (EQUAL (STOREA (ARRAY-PREV A) I V)
                                    (EMPTY-ARRAY))))
                   (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-PREV A) I V))
                          (ARRAY-ELT-SUBSCRIPT A))).

    Applying the lemma ARRAY-ELT-VALUE-ARRAY-ELT-SUBSCRIPT-ARRAY-PREV-ELIM,
    replace A by (ARRAY-SHELL X D Z) to eliminate (ARRAY-ELT-VALUE A),
    (ARRAY-PREV A), and (ARRAY-ELT-SUBSCRIPT A) and Z by (ARRAY-SHELL Z1 C X1)
    to eliminate (ARRAY-ELT-SUBSCRIPT Z), (ARRAY-PREV Z), and
    (ARRAY-ELT-VALUE Z).  We use the type restriction lemma noted when
    ARRAY-ELT-SUBSCRIPT was introduced and the type restriction lemma noted
    when ARRAY-PREV was introduced to restrict the new variables.  We thus
    obtain:

          (IMPLIES
                (AND (NUMBERP C)
                     (ARRAY-RECOGNIZER X1)
                     (NUMBERP D)
                     (NOT (EQUAL (ARRAY-SHELL X D
                                              (ARRAY-SHELL Z1 C X1))
                                 (EMPTY-ARRAY)))
                     (NOT (EQUAL X (UNDEFINED)))
                     (NOT (EQUAL (ARRAY-SHELL Z1 C X1)
                                 (EMPTY-ARRAY)))
                     (EQUAL (STOREA (STOREA (ARRAY-SHELL Z1 C X1) I V)
                                    I W)
                            (STOREA (ARRAY-SHELL Z1 C X1) I W))
                     (LESSP C D)
                     (ARRAYP (ARRAY-SHELL Z1 C X1))
                     (NUMBERP I)
                     (NOT (EQUAL D I))
                     (NOT (LESSP D I))
                     (NOT (EQUAL (STOREA (ARRAY-SHELL Z1 C X1) I V)
                                 (EMPTY-ARRAY))))
                (LESSP (ARRAY-ELT-SUBSCRIPT (STOREA (ARRAY-SHELL Z1 C X1) I V))
                       D)),

    which further simplifies, applying ARRAY-ELT-SUBSCRIPT-ARRAY-SHELL,
    ARRAY-ELT-VALUE-ARRAY-SHELL, and ARRAY-PREV-ARRAY-SHELL, and unfolding
    ARRAYP, STOREA, EQUAL, and ARRAY-RECOGNIZER, to the following six new
    goals:

    Case 2.5.6.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT X1) C)
                          (ARRAYP X1)
                          (EQUAL C I)
                          (NOT (EQUAL W (UNDEFINED)))
                          (EQUAL V (UNDEFINED))
                          (EQUAL (STOREA X1 I W)
                                 (ARRAY-SHELL W C X1))
                          (LESSP C D)
                          (NOT (EQUAL D C))
                          (NOT (LESSP D C))
                          (NOT (EQUAL X1 (EMPTY-ARRAY))))
                     (LESSP (ARRAY-ELT-SUBSCRIPT X1) D)).

      But this finally simplifies, using linear arithmetic, to:

            T.

    Case 2.5.5.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT X1) C)
                          (ARRAYP X1)
                          (EQUAL C I)
                          (EQUAL W (UNDEFINED))
                          (EQUAL V (UNDEFINED))
                          (EQUAL (STOREA X1 I W) X1)
                          (LESSP C D)
                          (NOT (EQUAL D C))
                          (NOT (LESSP D C))
                          (NOT (EQUAL X1 (EMPTY-ARRAY))))
                     (LESSP (ARRAY-ELT-SUBSCRIPT X1) D)),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.5.4.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (EQUAL X1 (EMPTY-ARRAY))
                          (NOT (EQUAL C I))
                          (LESSP C I)
                          (EQUAL W (UNDEFINED))
                          (NOT (EQUAL V (UNDEFINED)))
                          (EQUAL (STOREA (ARRAY-SHELL V I
                                                      (ARRAY-SHELL Z1 C X1))
                                         I W)
                                 (ARRAY-SHELL Z1 C X1))
                          (LESSP C D)
                          (NUMBERP I)
                          (NOT (EQUAL D I))
                          (NOT (LESSP D I)))
                     (LESSP I D)),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.5.3.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT X1) C)
                          (ARRAYP X1)
                          (NOT (EQUAL C I))
                          (LESSP C I)
                          (EQUAL W (UNDEFINED))
                          (NOT (EQUAL V (UNDEFINED)))
                          (EQUAL (STOREA (ARRAY-SHELL V I
                                                      (ARRAY-SHELL Z1 C X1))
                                         I W)
                                 (ARRAY-SHELL Z1 C X1))
                          (LESSP C D)
                          (NUMBERP I)
                          (NOT (EQUAL D I))
                          (NOT (LESSP D I)))
                     (LESSP I D)),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.5.2.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (EQUAL X1 (EMPTY-ARRAY))
                          (NOT (EQUAL C I))
                          (LESSP C I)
                          (NOT (EQUAL W (UNDEFINED)))
                          (NOT (EQUAL V (UNDEFINED)))
                          (EQUAL (STOREA (ARRAY-SHELL V I
                                                      (ARRAY-SHELL Z1 C X1))
                                         I W)
                                 (ARRAY-SHELL W I
                                              (ARRAY-SHELL Z1 C X1)))
                          (LESSP C D)
                          (NUMBERP I)
                          (NOT (EQUAL D I))
                          (NOT (LESSP D I)))
                     (LESSP I D)),

      which finally simplifies, using linear arithmetic, to:

            T.

    Case 2.5.1.
            (IMPLIES (AND (NUMBERP C)
                          (ARRAY-RECOGNIZER X1)
                          (NUMBERP D)
                          (NOT (EQUAL X (UNDEFINED)))
                          (NOT (EQUAL Z1 (UNDEFINED)))
                          (LESSP (ARRAY-ELT-SUBSCRIPT X1) C)
                          (ARRAYP X1)
                          (NOT (EQUAL C I))
                          (LESSP C I)
                          (NOT (EQUAL W (UNDEFINED)))
                          (NOT (EQUAL V (UNDEFINED)))
                          (EQUAL (STOREA (ARRAY-SHELL V I
                                                      (ARRAY-SHELL Z1 C X1))
                                         I W)
                                 (ARRAY-SHELL W I
                                              (ARRAY-SHELL Z1 C X1)))
                          (LESSP C D)
                          (NUMBERP I)
                          (NOT (EQUAL D I))
                          (NOT (LESSP D I)))
                     (LESSP I D)),

      which finally simplifies, using linear arithmetic, to:

            T.

  Case 2.4.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (ARRAY-PREV A) I W)
                          (ARRAY-PREV A))),

    which again simplifies, applying X-NOT-LESS-THAN-X, and expanding the
    functions EQUAL and STOREA, to:

          T.

  Case 2.3.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (EQUAL W (UNDEFINED))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (ARRAY-PREV A))
                                  I W)
                          (ARRAY-PREV A))).

    This again simplifies, applying X-NOT-LESS-THAN-X, and unfolding the
    definitions of STOREA and EQUAL, to:

          T.

  Case 2.2.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (EQUAL V (UNDEFINED)))
                   (EQUAL (STOREA (ARRAY-PREV A) I W)
                          (ARRAY-SHELL W I (ARRAY-PREV A)))).

    However this again simplifies, rewriting with X-NOT-LESS-THAN-X, and
    expanding the definitions of EQUAL and STOREA, to:

          T.

  Case 2.1.
          (IMPLIES (AND (ARRAY-RECOGNIZER A)
                        (NOT (EQUAL A (EMPTY-ARRAY)))
                        (NOT (EQUAL (ARRAY-ELT-VALUE A)
                                    (UNDEFINED)))
                        (NOT (EQUAL (ARRAY-PREV A) (EMPTY-ARRAY)))
                        (EQUAL (STOREA (STOREA (ARRAY-PREV A) I V)
                                       I W)
                               (STOREA (ARRAY-PREV A) I W))
                        (LESSP (ARRAY-ELT-SUBSCRIPT (ARRAY-PREV A))
                               (ARRAY-ELT-SUBSCRIPT A))
                        (ARRAYP (ARRAY-PREV A))
                        (NUMBERP I)
                        (EQUAL (ARRAY-ELT-SUBSCRIPT A) I)
                        (NOT (EQUAL W (UNDEFINED)))
                        (NOT (EQUAL V (UNDEFINED))))
                   (EQUAL (STOREA (ARRAY-SHELL V I (ARRAY-PREV A))
                                  I W)
                          (ARRAY-SHELL W I (ARRAY-PREV A)))).

    However this again simplifies, rewriting with X-NOT-LESS-THAN-X, and
    expanding the function STOREA, to:

          T.

Case 1. (IMPLIES (AND (NOT (ARRAY-RECOGNIZER A))
                      (ARRAYP A)
                      (NUMBERP I))
                 (EQUAL (STOREA (STOREA A I V) I W)
                        (STOREA A I W))).

  This simplifies, expanding ARRAYP, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.1 0.1 ]

(DEFN arrayconstruct (V I J) (IF (LESSP J I) (empty-array) (storea (arrayconstruct V (ADD1 I) J) I V)) ((LESSP (DIFFERENCE (ADD1 J) I))))
     Linear arithmetic establishes that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each recursive call.
Hence, ARRAYCONSTRUCT is accepted under the definitional principle.  Note that:
      (ARRAY-RECOGNIZER (ARRAYCONSTRUCT V I J))
is a theorem.




[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arrayconstruct-is-arrayp (REWRITE) (arrayp (arrayconstruct V I J)))

     Give the conjecture the name *1.


     We will try to prove it by induction.  There is only one suggested
induction.  We will induct according to the following scheme:
      (AND (IMPLIES (LESSP J I) (p V I J))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p V (ADD1 I) J))
                    (p V I J))).
Linear arithmetic informs us that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme leads to two new formulas:

Case 2. (IMPLIES (LESSP J I)
                 (ARRAYP (ARRAYCONSTRUCT V I J))),

  which simplifies, expanding the functions ARRAYCONSTRUCT and ARRAYP, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYP (ARRAYCONSTRUCT V (ADD1 I) J)))
                 (ARRAYP (ARRAYCONSTRUCT V I J))),

  which simplifies, applying the lemma STORE-IS-PROPER, and unfolding
  ARRAYCONSTRUCT, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(DCL alltrue (R))
[ 0.0 0.0 0.0 ]

(DCL selectr (R I))
[ 0.0 0.0 0.0 ]

(DCL storer (A B C))
[ 0.0 0.0 0.0 ]

(DEFN arraytrue (A I J) (IF (LESSP J I) T (AND (EQUAL (alltrue (selecta A I)) T) (arraytrue A (ADD1 I) J))) ((LESSP (DIFFERENCE (ADD1 J) I))))
     Linear arithmetic informs us that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each recursive call.
Hence, ARRAYTRUE is accepted under the principle of definition.  Note that:
      (OR (FALSEP (ARRAYTRUE A I J))
          (TRUEP (ARRAYTRUE A I J)))
is a theorem.




[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arraytrue-void-rule (REWRITE) (IMPLIES (LESSP J I) (arraytrue A I J)))
This simplifies, unfolding ARRAYTRUE, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arraytrue-single-rule (REWRITE) (EQUAL (EQUAL (arraytrue A I I) T) (EQUAL (alltrue (selecta A I)) T)))
This conjecture simplifies, using linear arithmetic, rewriting with
ARRAYTRUE-VOID-RULE and X-NOT-LESS-THAN-X, and expanding the definition of
ARRAYTRUE, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arraytrue-select-rule (REWRITE) (IMPLIES (AND (arraytrue A I J) (NUMBERP I) (NUMBERP J) (NUMBERP X) (NOT (LESSP X I)) (NOT (LESSP J X))) (alltrue (selecta A X))))
WARNING:  Note that ARRAYTRUE-SELECT-RULE contains the free variables J and I
which will be chosen by instantiating the hypothesis (ARRAYTRUE A I J).



     Call the conjecture *1.


     Perhaps we can prove it by induction.  The recursive terms in the
conjecture suggest six inductions.  They merge into three likely candidate
inductions.  However, only one is unflawed.  We will induct according to the
following scheme:
      (AND (IMPLIES (LESSP J I) (p A X J I))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p A X J (ADD1 I)))
                    (p A X J I))).
Linear arithmetic informs us that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme produces the following three new
conjectures:

Case 3. (IMPLIES (AND (LESSP J I)
                      (ARRAYTRUE A I J)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (ALLTRUE (SELECTA A X))).

  This simplifies, using linear arithmetic, to:

        T.

Case 2. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (ARRAYTRUE A (ADD1 I) J))
                      (ARRAYTRUE A I J)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (ALLTRUE (SELECTA A X))).

  This simplifies, expanding the definition of ARRAYTRUE, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (LESSP X (ADD1 I))
                      (ARRAYTRUE A I J)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (ALLTRUE (SELECTA A X))).

  This simplifies, using linear arithmetic, to:

        (IMPLIES (AND (NOT (LESSP J I))
                      (LESSP I (ADD1 I))
                      (ARRAYTRUE A I J)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP I)
                      (NOT (LESSP I I))
                      (NOT (LESSP J I)))
                 (ALLTRUE (SELECTA A I))),

  which again simplifies, rewriting with SUB1-ADD1, and expanding LESSP,
  NUMBERP, EQUAL, and ARRAYTRUE, to:

        (IMPLIES (AND (EQUAL I 0)
                      (ARRAYTRUE A 0 J)
                      (NUMBERP J))
                 (ALLTRUE (SELECTA A 0))),

  which again simplifies, opening up LESSP, EQUAL, and ARRAYTRUE, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arraytrue-unchanged-rule (REWRITE) (IMPLIES (AND (NUMBERP X) (NUMBERP I) (NUMBERP J) (arrayp A) (EQUAL (arraytrue A I J) T) (OR (LESSP X I) (LESSP J X))) (EQUAL (arraytrue (storea A X V) I J) T)))
This simplifies, opening up OR, to the following two new formulas:

Case 2. (IMPLIES (AND (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (ARRAYTRUE A I J)
                      (LESSP X I))
                 (ARRAYTRUE (STOREA A X V) I J)).

  Name the above subgoal *1.

Case 1. (IMPLIES (AND (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (ARRAYTRUE A I J)
                      (LESSP J X))
                 (ARRAYTRUE (STOREA A X V) I J)),

  which we would usually push and work on later by induction.  But if we must
  use induction to prove the input conjecture, we prefer to induct on the
  original formulation of the problem.  Thus we will disregard all that we
  have previously done, give the name *1 to the original input, and work on it.


     So now let us consider:

(AND (IMPLIES (AND (NUMBERP X)
                   (NUMBERP I)
                   (NUMBERP J)
                   (ARRAYP A)
                   (EQUAL (ARRAYTRUE A I J) T)
                   (LESSP J X))
              (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                     T))
     (IMPLIES (AND (NUMBERP X)
                   (NUMBERP I)
                   (NUMBERP J)
                   (ARRAYP A)
                   (EQUAL (ARRAYTRUE A I J) T)
                   (LESSP X I))
              (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                     T))).

We gave this the name *1 above.  Perhaps we can prove it by induction.  The
recursive terms in the conjecture suggest 12 inductions.  They merge into
three likely candidate inductions.  However, only one is unflawed.  We will
induct according to the following scheme:
      (AND (IMPLIES (LESSP J I) (p A X V I J))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p A X V (ADD1 I) J))
                    (p A X V I J))).
Linear arithmetic establishes that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme generates the following seven new
goals:

Case 7. (IMPLIES (AND (LESSP J I)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP J X))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)).

  This simplifies, rewriting with the lemma ARRAYTRUE-VOID-RULE, and opening
  up the function EQUAL, to:

        T.

Case 6. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (EQUAL (ARRAYTRUE A (ADD1 I) J) T))
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP J X))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)).

  This simplifies, unfolding the functions ARRAYTRUE and EQUAL, to:

        T.

Case 5. (IMPLIES (AND (NOT (LESSP J I))
                      (EQUAL (ARRAYTRUE (STOREA A X V) (ADD1 I) J)
                             T)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP J X))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)).

  This simplifies, appealing to the lemma SELECT-OF-STORE, and unfolding the
  function ARRAYTRUE, to the new formula:

        (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYTRUE (STOREA A X V) (ADD1 I) J)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ALLTRUE (SELECTA A I)) T)
                      (ARRAYTRUE A (ADD1 I) J)
                      (LESSP J X)
                      (EQUAL X I))
                 (EQUAL (ALLTRUE V) T)),

  which again simplifies, trivially, to:

        T.

Case 4. (IMPLIES (AND (LESSP J I)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP X I))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)).

  This simplifies, applying ARRAYTRUE-VOID-RULE, and opening up the definition
  of EQUAL, to:

        T.

Case 3. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (LESSP J X))
                      (NOT (LESSP X (ADD1 I)))
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP X I))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)),

  which simplifies, using linear arithmetic, to:

        T.

Case 2. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (EQUAL (ARRAYTRUE A (ADD1 I) J) T))
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP X I))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)),

  which simplifies, unfolding ARRAYTRUE and EQUAL, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (EQUAL (ARRAYTRUE (STOREA A X V) (ADD1 I) J)
                             T)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ARRAYTRUE A I J) T)
                      (LESSP X I))
                 (EQUAL (ARRAYTRUE (STOREA A X V) I J)
                        T)),

  which simplifies, rewriting with SELECT-OF-STORE, and expanding the function
  ARRAYTRUE, to:

        (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYTRUE (STOREA A X V) (ADD1 I) J)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ALLTRUE (SELECTA A I)) T)
                      (ARRAYTRUE A (ADD1 I) J)
                      (LESSP X I)
                      (EQUAL X I))
                 (EQUAL (ALLTRUE V) T)),

  which again simplifies, using linear arithmetic, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.1 0.0 ]

(PROVE-LEMMA arraytrue-unchanged-2-rule (REWRITE) (IMPLIES (AND (NUMBERP X) (NUMBERP I) (NUMBERP J) (arrayp A) (EQUAL (alltrue V) T) (EQUAL (arraytrue A I J) T)) (EQUAL (arraytrue (storea A X V) I J) T)))

     Name the conjecture *1.


     Perhaps we can prove it by induction.  Four inductions are suggested by
terms in the conjecture.  They merge into two likely candidate inductions.
However, only one is unflawed.  We will induct according to the following
scheme:
      (AND (IMPLIES (LESSP J I) (p A X V I J))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p A X V (ADD1 I) J))
                    (p A X V I J))).
Linear arithmetic establishes that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme leads to the following three new
formulas:

Case 3. (IMPLIES (AND (LESSP J I)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ALLTRUE V) T)
                      (ARRAYTRUE A I J))
                 (ARRAYTRUE (STOREA A X V) I J)).

  This simplifies, applying ARRAYTRUE-VOID-RULE, to:

        T.

Case 2. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (ARRAYTRUE A (ADD1 I) J))
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ALLTRUE V) T)
                      (ARRAYTRUE A I J))
                 (ARRAYTRUE (STOREA A X V) I J)),

  which simplifies, opening up the definition of ARRAYTRUE, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYTRUE (STOREA A X V) (ADD1 I) J)
                      (NUMBERP X)
                      (NUMBERP I)
                      (NUMBERP J)
                      (ARRAYP A)
                      (EQUAL (ALLTRUE V) T)
                      (ARRAYTRUE A I J))
                 (ARRAYTRUE (STOREA A X V) I J)),

  which simplifies, applying SELECT-OF-STORE, and opening up the definition of
  ARRAYTRUE, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arraytrue-extend-upward-rule (REWRITE) (IMPLIES (AND (EQUAL (arraytrue A I J) T) (EQUAL (alltrue (selecta A (ADD1 J))) T)) (EQUAL (arraytrue A I (ADD1 J)) T)))

     Name the conjecture *1.


     We will try to prove it by induction.  There are three plausible
inductions.  They merge into two likely candidate inductions.  However, only
one is unflawed.  We will induct according to the following scheme:
      (AND (IMPLIES (LESSP J I) (p A I J))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p A (ADD1 I) J))
                    (p A I J))).
Linear arithmetic informs us that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme leads to three new formulas:

Case 3. (IMPLIES (AND (LESSP J I)
                      (ARRAYTRUE A I J)
                      (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                             T))
                 (ARRAYTRUE A I (ADD1 J))),

  which simplifies, rewriting with ARRAYTRUE-VOID-RULE and SUB1-ADD1, and
  opening up ARRAYTRUE and LESSP, to the following eight new conjectures:

  Case 3.8.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NOT (NUMBERP I)))
                   (ARRAYTRUE A (ADD1 I) (ADD1 J))).

    But this again simplifies, opening up LESSP, to:

          T.

  Case 3.7.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (EQUAL I 0))
                   (ARRAYTRUE A (ADD1 I) (ADD1 J))),

    which again simplifies, using linear arithmetic, to:

          T.

  Case 3.6.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NOT (NUMBERP I)))
                   (EQUAL (ALLTRUE (SELECTA A I)) T)),

    which again simplifies, expanding LESSP, to:

          T.

  Case 3.5.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (EQUAL I 0))
                   (EQUAL (ALLTRUE (SELECTA A I)) T)),

    which again simplifies, using linear arithmetic, to:

          T.

  Case 3.4.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NUMBERP J)
                        (NOT (LESSP J (SUB1 I))))
                   (ARRAYTRUE A (ADD1 I) (ADD1 J))),

    which again simplifies, using linear arithmetic, to two new goals:

    Case 3.4.2.
            (IMPLIES (AND (NOT (NUMBERP I))
                          (LESSP J I)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NUMBERP J)
                          (NOT (LESSP J (SUB1 I))))
                     (ARRAYTRUE A (ADD1 I) (ADD1 J))),

      which again simplifies, expanding the function LESSP, to:

            T.

    Case 3.4.1.
            (IMPLIES (AND (NUMBERP I)
                          (LESSP J (PLUS 1 J))
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NUMBERP J)
                          (NOT (LESSP J (SUB1 (PLUS 1 J)))))
                     (ARRAYTRUE A
                                (ADD1 (PLUS 1 J))
                                (ADD1 J))),

      which again simplifies, using linear arithmetic, applying the lemmas
      PLUS-1, SUB1-ADD1, ARRAYTRUE-VOID-RULE, and X-NOT-LESS-THAN-X, and
      unfolding LESSP, ADD1, NUMBERP, PLUS, and SUB1, to:

            T.

  Case 3.3.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NUMBERP J)
                        (NOT (LESSP J (SUB1 I))))
                   (EQUAL (ALLTRUE (SELECTA A I)) T)),

    which again simplifies, using linear arithmetic, to two new conjectures:

    Case 3.3.2.
            (IMPLIES (AND (NOT (NUMBERP I))
                          (LESSP J I)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NUMBERP J)
                          (NOT (LESSP J (SUB1 I))))
                     (EQUAL (ALLTRUE (SELECTA A I)) T)),

      which again simplifies, unfolding LESSP, to:

            T.

    Case 3.3.1.
            (IMPLIES (AND (NUMBERP I)
                          (LESSP J (PLUS 1 J))
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NUMBERP J)
                          (NOT (LESSP J (SUB1 (PLUS 1 J)))))
                     (EQUAL (ALLTRUE (SELECTA A (PLUS 1 J)))
                            T)),

      which again simplifies, applying PLUS-1, SUB1-ADD1, and
      X-NOT-LESS-THAN-X, and expanding the functions LESSP, ADD1, NUMBERP,
      PLUS, SUB1, and EQUAL, to:

            T.

  Case 3.2.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NOT (NUMBERP J))
                        (NOT (LESSP 0 (SUB1 I))))
                   (ARRAYTRUE A (ADD1 I) (ADD1 J))).

    This again simplifies, using linear arithmetic, to two new formulas:

    Case 3.2.2.
            (IMPLIES (AND (NOT (NUMBERP I))
                          (LESSP J I)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NOT (NUMBERP J))
                          (NOT (LESSP 0 (SUB1 I))))
                     (ARRAYTRUE A (ADD1 I) (ADD1 J))),

      which again simplifies, opening up the definition of LESSP, to:

            T.

    Case 3.2.1.
            (IMPLIES (AND (NUMBERP I)
                          (LESSP J 1)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NOT (NUMBERP J))
                          (NOT (LESSP 0 (SUB1 1))))
                     (ARRAYTRUE A 2 (ADD1 J))),

      which again simplifies, applying SUB1-TYPE-RESTRICTION and
      ARRAYTRUE-VOID-RULE, and opening up the definitions of NUMBERP, EQUAL,
      LESSP, and SUB1, to:

            T.

  Case 3.1.
          (IMPLIES (AND (LESSP J I)
                        (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                               T)
                        (NOT (NUMBERP J))
                        (NOT (LESSP 0 (SUB1 I))))
                   (EQUAL (ALLTRUE (SELECTA A I)) T)).

    This again simplifies, using linear arithmetic, to two new conjectures:

    Case 3.1.2.
            (IMPLIES (AND (NOT (NUMBERP I))
                          (LESSP J I)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NOT (NUMBERP J))
                          (NOT (LESSP 0 (SUB1 I))))
                     (EQUAL (ALLTRUE (SELECTA A I)) T)),

      which again simplifies, opening up LESSP, to:

            T.

    Case 3.1.1.
            (IMPLIES (AND (NUMBERP I)
                          (LESSP J 1)
                          (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                                 T)
                          (NOT (NUMBERP J))
                          (NOT (LESSP 0 (SUB1 1))))
                     (EQUAL (ALLTRUE (SELECTA A 1)) T)),

      which again simplifies, rewriting with SUB1-TYPE-RESTRICTION, and
      expanding the definitions of NUMBERP, EQUAL, and LESSP, to:

            T.

Case 2. (IMPLIES (AND (NOT (LESSP J I))
                      (NOT (ARRAYTRUE A (ADD1 I) J))
                      (ARRAYTRUE A I J)
                      (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                             T))
                 (ARRAYTRUE A I (ADD1 J))).

  This simplifies, unfolding ARRAYTRUE, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYTRUE A (ADD1 I) (ADD1 J))
                      (ARRAYTRUE A I J)
                      (EQUAL (ALLTRUE (SELECTA A (ADD1 J)))
                             T))
                 (ARRAYTRUE A I (ADD1 J))).

  This simplifies, rewriting with the lemma SUB1-ADD1, and expanding the
  definitions of ARRAYTRUE, LESSP, and EQUAL, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arrayconstruct-implies-arraytrue-rule (REWRITE) (IMPLIES (AND (NUMBERP I) (NUMBERP J) (EQUAL (alltrue V) T)) (EQUAL (arraytrue (arrayconstruct V I J) I J) T)))

     Name the conjecture *1.


     We will appeal to induction.  The recursive terms in the conjecture
suggest two inductions.  However, they merge into one likely candidate
induction.  We will induct according to the following scheme:
      (AND (IMPLIES (LESSP J I) (p V I J))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p V (ADD1 I) J))
                    (p V I J))).
Linear arithmetic informs us that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme generates the following two new
conjectures:

Case 2. (IMPLIES (AND (LESSP J I)
                      (NUMBERP I)
                      (NUMBERP J)
                      (EQUAL (ALLTRUE V) T))
                 (ARRAYTRUE (ARRAYCONSTRUCT V I J)
                            I J)).

  This simplifies, rewriting with ARRAYTRUE-VOID-RULE, and expanding
  ARRAYCONSTRUCT, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (ARRAYTRUE (ARRAYCONSTRUCT V (ADD1 I) J)
                                 (ADD1 I)
                                 J)
                      (NUMBERP I)
                      (NUMBERP J)
                      (EQUAL (ALLTRUE V) T))
                 (ARRAYTRUE (ARRAYCONSTRUCT V I J)
                            I J)),

  which simplifies, applying ARRAYTRUE-UNCHANGED-2-RULE, SELECT-OF-STORE, and
  ARRAYCONSTRUCT-IS-ARRAYP, and expanding the functions ARRAYCONSTRUCT, EQUAL,
  and ARRAYTRUE, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA select-of-construct-0 (REWRITE) (IMPLIES (NUMBERP j) (EQUAL (arrayconstruct v 0 j) (storea (arrayconstruct v 1 j) 0 v))))
This simplifies, expanding ADD1, LESSP, EQUAL, and ARRAYCONSTRUCT, to:

      T.

Q.E.D.


[ 0.0 0.0 0.0 ]

(PROVE-LEMMA arrayconstruct-select-rule (REWRITE) (IMPLIES (AND (NUMBERP I) (NUMBERP J) (NUMBERP X) (NOT (LESSP X I)) (NOT (LESSP J X))) (EQUAL (selecta (arrayconstruct V I J) X) V)))

     Name the conjecture *1.


     We will appeal to induction.  There are five plausible inductions.  They
merge into two likely candidate inductions.  However, only one is unflawed.
We will induct according to the following scheme:
      (AND (IMPLIES (LESSP J I) (p V I J X))
           (IMPLIES (AND (NOT (LESSP J I))
                         (p V (ADD1 I) J X))
                    (p V I J X))).
Linear arithmetic can be used to show that the measure (DIFFERENCE (ADD1 J) I)
decreases according to the well-founded relation LESSP in each induction step
of the scheme.  The above induction scheme generates three new conjectures:

Case 3. (IMPLIES (AND (LESSP J I)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (EQUAL (SELECTA (ARRAYCONSTRUCT V I J) X)
                        V)),

  which simplifies, using linear arithmetic, to:

        T.

Case 2. (IMPLIES (AND (NOT (LESSP J I))
                      (LESSP X (ADD1 I))
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (EQUAL (SELECTA (ARRAYCONSTRUCT V I J) X)
                        V)),

  which simplifies, using linear arithmetic, to:

        (IMPLIES (AND (NOT (LESSP J I))
                      (LESSP I (ADD1 I))
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP I)
                      (NOT (LESSP I I))
                      (NOT (LESSP J I)))
                 (EQUAL (SELECTA (ARRAYCONSTRUCT V I J) I)
                        V)).

  But this again simplifies, rewriting with SUB1-ADD1, SELECT-OF-CONSTRUCT-0,
  ARRAYCONSTRUCT-IS-ARRAYP, SELECT-OF-STORE, and X-NOT-LESS-THAN-X, and
  expanding the definitions of LESSP, NUMBERP, EQUAL, and ARRAYCONSTRUCT, to:

        T.

Case 1. (IMPLIES (AND (NOT (LESSP J I))
                      (EQUAL (SELECTA (ARRAYCONSTRUCT V (ADD1 I) J)
                                      X)
                             V)
                      (NUMBERP I)
                      (NUMBERP J)
                      (NUMBERP X)
                      (NOT (LESSP X I))
                      (NOT (LESSP J X)))
                 (EQUAL (SELECTA (ARRAYCONSTRUCT V I J) X)
                        V)).

  This simplifies, applying ARRAYCONSTRUCT-IS-ARRAYP and SELECT-OF-STORE, and
  opening up the definition of ARRAYCONSTRUCT, to:

        T.


     That finishes the proof of *1.  Q.E.D.


[ 0.0 0.0 0.0 ]

;; Loaded file ../../verifier/pasv/src/work/temporaryrulebase.lisp
T
[6]> 
Bye.
